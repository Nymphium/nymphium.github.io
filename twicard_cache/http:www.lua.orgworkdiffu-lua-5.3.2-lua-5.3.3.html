<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Lua: diffu-lua-5.3.2-lua-5.3.3</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../lua.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="diffs.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
</HEAD>

<BODY>

<H1>
<A HREF="../home.html"><IMG SRC="../images/logo.gif" ALT="Lua"></A>
diffu-lua-5.3.2-lua-5.3.3
</H1>

<DIV CLASS="menubar">
<A HREF="diffu-lua-5.3.2-lua-5.3.3.txt">raw</A>
&middot;
<A HREF="diffs-lua-5.3.2-lua-5.3.3.html">simple</A>
&middot;
<A HREF="diffu-lua-5.3.2-lua-5.3.3.html">unified</A>
&middot;
<A HREF="./">work</A>
</DIV>

<PRE>

<SPAN CLASS="diff">Makefile</SPAN>

<SPAN CLASS="etc">@@ -46,7 +46,7 @@</SPAN>
 
 # Lua version and release.
 V= 5.3
<SPAN CLASS="del">-R= $V.2</SPAN>
<SPAN CLASS="add">+R= $V.3</SPAN>
 
 # Targets start here.
 all:	$(PLAT)

<SPAN CLASS="diff">README</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 
<SPAN CLASS="del">-This is Lua 5.3.2, released on 25 Nov 2015.</SPAN>
<SPAN CLASS="add">+This is Lua 5.3.3, released on 30 May 2016.</SPAN>
 
 For installation instructions, license details, and
 further information about Lua, see doc/readme.html.

<SPAN CLASS="diff">doc/contents.html</SPAN>

<SPAN CLASS="etc">@@ -32,7 +32,7 @@</SPAN>
 
 &lt;P&gt;
 &lt;SMALL&gt;
<SPAN CLASS="del">-Copyright &amp;copy; 2015 Lua.org, PUC-Rio.</SPAN>
<SPAN CLASS="add">+Copyright &amp;copy; 2015&amp;ndash;2016 Lua.org, PUC-Rio.</SPAN>
 Freely available under the terms of the
 &lt;A HREF="http://www.lua.org/license.html"&gt;Lua license&lt;/A&gt;.
 &lt;/SMALL&gt;

<SPAN CLASS="etc">@@ -608,10 +608,10 @@</SPAN>
 
 &lt;P CLASS="footer"&gt;
 Last update:
<SPAN CLASS="del">-Wed Jun  3 08:27:30 BRT 2015</SPAN>
<SPAN CLASS="add">+Thu Jan 14 10:14:28 BRST 2016</SPAN>
 &lt;/P&gt;
 &lt;!--
<SPAN CLASS="del">-Last change: revised for Lua 5.3.1</SPAN>
<SPAN CLASS="add">+Last change: revised for Lua 5.3.3</SPAN>
 --&gt;
 
 &lt;/BODY&gt;

<SPAN CLASS="diff">doc/lua.css</SPAN>

<SPAN CLASS="etc">@@ -92,6 +92,7 @@</SPAN>
 .footer {
 	color: gray ;
 	font-size: x-small ;
<SPAN CLASS="add">+	text-transform: lowercase ;</SPAN>
 }
 
 input[type=text] {

<SPAN CLASS="etc">@@ -157,3 +158,7 @@</SPAN>
 	display: block ;
 	margin-top: 0.25em ;
 }
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+img {</SPAN>
<SPAN CLASS="add">+	background-color: white ;</SPAN>
<SPAN CLASS="add">+}</SPAN>

<SPAN CLASS="diff">doc/manual.html</SPAN>

<SPAN CLASS="etc">@@ -19,7 +19,7 @@</SPAN>
 
 &lt;P&gt;
 &lt;SMALL&gt;
<SPAN CLASS="del">-Copyright &amp;copy; 2015 Lua.org, PUC-Rio.</SPAN>
<SPAN CLASS="add">+Copyright &amp;copy; 2015&amp;ndash;2016 Lua.org, PUC-Rio.</SPAN>
 Freely available under the terms of the
 &lt;a href="http://www.lua.org/license.html"&gt;Lua license&lt;/a&gt;.
 &lt;/SMALL&gt;

<SPAN CLASS="etc">@@ -35,7 +35,7 @@</SPAN>
 &lt;!-- ====================================================================== --&gt;
 &lt;p&gt;
 
<SPAN CLASS="del">-&lt;!-- $Id: manual.of,v 1.153 2015/11/25 16:57:42 roberto Exp $ --&gt;</SPAN>
<SPAN CLASS="add">+&lt;!-- $Id: manual.of,v 1.162 2016/05/30 15:57:03 roberto Exp $ --&gt;</SPAN>
 
 
 

<SPAN CLASS="etc">@@ -43,30 +43,47 @@</SPAN>
 &lt;h1&gt;1 &amp;ndash; &lt;a name="1"&gt;Introduction&lt;/a&gt;&lt;/h1&gt;
 
 &lt;p&gt;
<SPAN CLASS="del">-Lua is an extension programming language designed to support</SPAN>
<SPAN CLASS="del">-general procedural programming with data description</SPAN>
<SPAN CLASS="del">-facilities.</SPAN>
<SPAN CLASS="del">-Lua also offers good support for object-oriented programming,</SPAN>
<SPAN CLASS="del">-functional programming, and data-driven programming.</SPAN>
<SPAN CLASS="del">-Lua is intended to be used as a powerful, lightweight,</SPAN>
<SPAN CLASS="del">-embeddable scripting language for any program that needs one.</SPAN>
<SPAN CLASS="add">+Lua is a powerful, efficient, lightweight, embeddable scripting language.</SPAN>
<SPAN CLASS="add">+It supports procedural programming,</SPAN>
<SPAN CLASS="add">+object-oriented programming, functional programming,</SPAN>
<SPAN CLASS="add">+data-driven programming, and data description.</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+&lt;p&gt;</SPAN>
<SPAN CLASS="add">+Lua combines simple procedural syntax with powerful data description</SPAN>
<SPAN CLASS="add">+constructs based on associative arrays and extensible semantics.</SPAN>
<SPAN CLASS="add">+Lua is dynamically typed,</SPAN>
<SPAN CLASS="add">+runs by interpreting bytecode with a register-based</SPAN>
<SPAN CLASS="add">+virtual machine,</SPAN>
<SPAN CLASS="add">+and has automatic memory management with</SPAN>
<SPAN CLASS="add">+incremental garbage collection,</SPAN>
<SPAN CLASS="add">+making it ideal for configuration, scripting,</SPAN>
<SPAN CLASS="add">+and rapid prototyping.</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+&lt;p&gt;</SPAN>
 Lua is implemented as a library, written in &lt;em&gt;clean C&lt;/em&gt;,
 the common subset of Standard&amp;nbsp;C and C++.
<SPAN CLASS="add">+The Lua distribution includes a host program called &lt;code&gt;lua&lt;/code&gt;,</SPAN>
<SPAN CLASS="add">+which uses the Lua library to offer a complete,</SPAN>
<SPAN CLASS="add">+standalone Lua interpreter,</SPAN>
<SPAN CLASS="add">+for interactive or batch use.</SPAN>
<SPAN CLASS="add">+Lua is intended to be used both as a powerful, lightweight,</SPAN>
<SPAN CLASS="add">+embeddable scripting language for any program that needs one,</SPAN>
<SPAN CLASS="add">+and as a powerful but lightweight and efficient stand-alone language.</SPAN>
 
 
 &lt;p&gt;
 As an extension language, Lua has no notion of a "main" program:
<SPAN CLASS="del">-it only works &lt;em&gt;embedded&lt;/em&gt; in a host client,</SPAN>
<SPAN CLASS="add">+it works &lt;em&gt;embedded&lt;/em&gt; in a host client,</SPAN>
 called the &lt;em&gt;embedding program&lt;/em&gt; or simply the &lt;em&gt;host&lt;/em&gt;.
<SPAN CLASS="add">+(Frequently, this host is the stand-alone &lt;code&gt;lua&lt;/code&gt; program.)</SPAN>
 The host program can invoke functions to execute a piece of Lua code,
 can write and read Lua variables,
 and can register C&amp;nbsp;functions to be called by Lua code.
 Through the use of C&amp;nbsp;functions, Lua can be augmented to cope with
 a wide range of different domains,
 thus creating customized programming languages sharing a syntactical framework.
<SPAN CLASS="del">-The Lua distribution includes a sample host program called &lt;code&gt;lua&lt;/code&gt;,</SPAN>
<SPAN CLASS="del">-which uses the Lua library to offer a complete, standalone Lua interpreter,</SPAN>
<SPAN CLASS="del">-for interactive or batch use.</SPAN>
 
 
 &lt;p&gt;

<SPAN CLASS="etc">@@ -351,8 +368,8 @@</SPAN>
 When you use &lt;a href="#pdf-xpcall"&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt; or &lt;a href="#lua_pcall"&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;,
 you may give a &lt;em&gt;message handler&lt;/em&gt;
 to be called in case of errors.
<SPAN CLASS="del">-This function is called with the original error message</SPAN>
<SPAN CLASS="del">-and returns a new error message.</SPAN>
<SPAN CLASS="add">+This function is called with the original error object</SPAN>
<SPAN CLASS="add">+and returns a new error object.</SPAN>
 It is called before the error unwinds the stack,
 so that it can gather more information about the error,
 for instance by inspecting the stack and creating a stack traceback.

<SPAN CLASS="etc">@@ -382,16 +399,23 @@</SPAN>
 
 
 &lt;p&gt;
<SPAN CLASS="del">-The keys in a metatable are derived from the &lt;em&gt;event&lt;/em&gt; names;</SPAN>
<SPAN CLASS="add">+The key for each event in a metatable is a string</SPAN>
<SPAN CLASS="add">+with the event name prefixed by two underscores;</SPAN>
 the corresponding values are called &lt;em&gt;metamethods&lt;/em&gt;.
<SPAN CLASS="del">-In the previous example, the event is &lt;code&gt;"add"&lt;/code&gt;</SPAN>
<SPAN CLASS="add">+In the previous example, the key is "&lt;code&gt;__add&lt;/code&gt;"</SPAN>
 and the metamethod is the function that performs the addition.
 
 
 &lt;p&gt;
 You can query the metatable of any value
 using the &lt;a href="#pdf-getmetatable"&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt; function.
<SPAN CLASS="add">+Lua queries metamethods in metatables using a raw access (see &lt;a href="#pdf-rawget"&gt;&lt;code&gt;rawget&lt;/code&gt;&lt;/a&gt;).</SPAN>
<SPAN CLASS="add">+So, to retrieve the metamethod for event &lt;code&gt;ev&lt;/code&gt; in object &lt;code&gt;o&lt;/code&gt;,</SPAN>
<SPAN CLASS="add">+Lua does the equivalent to the following code:</SPAN>
 
<SPAN CLASS="add">+&lt;pre&gt;</SPAN>
<SPAN CLASS="add">+     rawget(getmetatable(&lt;em&gt;o&lt;/em&gt;) or {}, "__&lt;em&gt;ev&lt;/em&gt;")</SPAN>
<SPAN CLASS="add">+&lt;/pre&gt;</SPAN>
 
 &lt;p&gt;
 You can replace the metatable of tables

<SPAN CLASS="etc">@@ -420,18 +444,7 @@</SPAN>
 
 
 &lt;p&gt;
<SPAN CLASS="del">-A detailed list of events controlled by metatables is given next.</SPAN>
<SPAN CLASS="del">-Each operation is identified by its corresponding event name.</SPAN>
<SPAN CLASS="del">-The key for each event is a string with its name prefixed by</SPAN>
<SPAN CLASS="del">-two underscores, '&lt;code&gt;__&lt;/code&gt;';</SPAN>
<SPAN CLASS="del">-for instance, the key for operation "add" is the</SPAN>
<SPAN CLASS="del">-string "&lt;code&gt;__add&lt;/code&gt;".</SPAN>
<SPAN CLASS="del">-Note that queries for metamethods are always raw;</SPAN>
<SPAN CLASS="del">-the access to a metamethod does not invoke other metamethods.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-&lt;p&gt;</SPAN>
<SPAN CLASS="del">-For the unary operators (negation, length, and bitwise not),</SPAN>
<SPAN CLASS="add">+For the unary operators (negation, length, and bitwise NOT),</SPAN>
 the metamethod is computed and called with a dummy second operand,
 equal to the first one.
 This extra operand is only to simplify Lua's internals

<SPAN CLASS="etc">@@ -440,17 +453,21 @@</SPAN>
 (For most uses this extra operand is irrelevant.)
 
 
<SPAN CLASS="add">+&lt;p&gt;</SPAN>
<SPAN CLASS="add">+A detailed list of events controlled by metatables is given next.</SPAN>
<SPAN CLASS="add">+Each operation is identified by its corresponding key.</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
 
 &lt;ul&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"add": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;+&lt;/code&gt; operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__add&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the addition (&lt;code&gt;+&lt;/code&gt;) operation.</SPAN>
 If any operand for an addition is not a number
 (nor a string coercible to a number),
 Lua will try to call a metamethod.
 First, Lua will check the first operand (even if it is valid).
<SPAN CLASS="del">-If that operand does not define a metamethod for the "&lt;code&gt;__add&lt;/code&gt;" event,</SPAN>
<SPAN CLASS="add">+If that operand does not define a metamethod for &lt;code&gt;__add&lt;/code&gt;,</SPAN>
 then Lua will check the second operand.
 If Lua can find a metamethod,
 it calls the metamethod with the two operands as arguments,

<SPAN CLASS="etc">@@ -461,99 +478,84 @@</SPAN>
 it raises an error.
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"sub": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;-&lt;/code&gt; operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "add" operation.</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__sub&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the subtraction (&lt;code&gt;-&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the addition operation.</SPAN>
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"mul": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;*&lt;/code&gt; operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "add" operation.</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__mul&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the multiplication (&lt;code&gt;*&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the addition operation.</SPAN>
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"div": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;/&lt;/code&gt; operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "add" operation.</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__div&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the division (&lt;code&gt;/&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the addition operation.</SPAN>
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"mod": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;%&lt;/code&gt; operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "add" operation.</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__mod&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the modulo (&lt;code&gt;%&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the addition operation.</SPAN>
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"pow": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;^&lt;/code&gt; (exponentiation) operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "add" operation.</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__pow&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the exponentiation (&lt;code&gt;^&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the addition operation.</SPAN>
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"unm": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;-&lt;/code&gt; (unary minus) operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "add" operation.</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__unm&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the negation (unary &lt;code&gt;-&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the addition operation.</SPAN>
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"idiv": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;//&lt;/code&gt; (floor division) operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "add" operation.</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__idiv&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the floor division (&lt;code&gt;//&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the addition operation.</SPAN>
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"band": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;&amp;amp;&lt;/code&gt; (bitwise and) operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "add" operation,</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__band&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the bitwise AND (&lt;code&gt;&amp;amp;&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the addition operation,</SPAN>
 except that Lua will try a metamethod
 if any operand is neither an integer
 nor a value coercible to an integer (see &lt;a href="#3.4.3"&gt;&amp;sect;3.4.3&lt;/a&gt;).
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"bor": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;|&lt;/code&gt; (bitwise or) operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "band" operation.</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__bor&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the bitwise OR (&lt;code&gt;|&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the bitwise AND operation.</SPAN>
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"bxor": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;~&lt;/code&gt; (bitwise exclusive or) operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "band" operation.</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__bxor&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the bitwise exclusive OR (binary &lt;code&gt;~&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the bitwise AND operation.</SPAN>
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"bnot": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;~&lt;/code&gt; (bitwise unary not) operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "band" operation.</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__bnot&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the bitwise NOT (unary &lt;code&gt;~&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the bitwise AND operation.</SPAN>
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"shl": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; (bitwise left shift) operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "band" operation.</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__shl&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the bitwise left shift (&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the bitwise AND operation.</SPAN>
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"shr": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (bitwise right shift) operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "band" operation.</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__shr&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the bitwise right shift (&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the bitwise AND operation.</SPAN>
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"concat": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;..&lt;/code&gt; (concatenation) operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "add" operation,</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__concat&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the concatenation (&lt;code&gt;..&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the addition operation,</SPAN>
 except that Lua will try a metamethod
 if any operand is neither a string nor a number
 (which is always coercible to a string).
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"len": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;#&lt;/code&gt; (length) operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__len&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the length (&lt;code&gt;#&lt;/code&gt;) operation.</SPAN>
 If the object is not a string,
 Lua will try its metamethod.
 If there is a metamethod,

<SPAN CLASS="etc">@@ -566,44 +568,40 @@</SPAN>
 Otherwise, Lua raises an error.
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"eq": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;==&lt;/code&gt; (equal) operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "add" operation,</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__eq&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the equal (&lt;code&gt;==&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the addition operation,</SPAN>
 except that Lua will try a metamethod only when the values
 being compared are either both tables or both full userdata
 and they are not primitively equal.
 The result of the call is always converted to a boolean.
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"lt": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;&amp;lt;&lt;/code&gt; (less than) operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-Behavior similar to the "add" operation,</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__lt&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the less than (&lt;code&gt;&amp;lt;&lt;/code&gt;) operation.</SPAN>
<SPAN CLASS="add">+Behavior similar to the addition operation,</SPAN>
 except that Lua will try a metamethod only when the values
 being compared are neither both numbers nor both strings.
 The result of the call is always converted to a boolean.
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"le": &lt;/b&gt;</SPAN>
<SPAN CLASS="del">-the &lt;code&gt;&amp;lt;=&lt;/code&gt; (less equal) operation.</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__le&lt;/code&gt;: &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+the less equal (&lt;code&gt;&amp;lt;=&lt;/code&gt;) operation.</SPAN>
 Unlike other operations,
 the less-equal operation can use two different events.
<SPAN CLASS="del">-First, Lua looks for the "&lt;code&gt;__le&lt;/code&gt;" metamethod in both operands,</SPAN>
<SPAN CLASS="del">-like in the "lt" operation.</SPAN>
<SPAN CLASS="add">+First, Lua looks for the &lt;code&gt;__le&lt;/code&gt; metamethod in both operands,</SPAN>
<SPAN CLASS="add">+like in the less than operation.</SPAN>
 If it cannot find such a metamethod,
<SPAN CLASS="del">-then it will try the "&lt;code&gt;__lt&lt;/code&gt;" event,</SPAN>
<SPAN CLASS="add">+then it will try the &lt;code&gt;__lt&lt;/code&gt; metamethod,</SPAN>
 assuming that &lt;code&gt;a &amp;lt;= b&lt;/code&gt; is equivalent to &lt;code&gt;not (b &amp;lt; a)&lt;/code&gt;.
 As with the other comparison operators,
 the result is always a boolean.
<SPAN CLASS="del">-(This use of the "&lt;code&gt;__lt&lt;/code&gt;" event can be removed in future versions;</SPAN>
<SPAN CLASS="del">-it is also slower than a real "&lt;code&gt;__le&lt;/code&gt;" metamethod.)</SPAN>
<SPAN CLASS="add">+(This use of the &lt;code&gt;__lt&lt;/code&gt; event can be removed in future versions;</SPAN>
<SPAN CLASS="add">+it is also slower than a real &lt;code&gt;__le&lt;/code&gt; metamethod.)</SPAN>
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"index": &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__index&lt;/code&gt;: &lt;/b&gt;</SPAN>
 The indexing access &lt;code&gt;table[key]&lt;/code&gt;.
<SPAN CLASS="del">-</SPAN>
 This event happens when &lt;code&gt;table&lt;/code&gt; is not a table or
 when &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;table&lt;/code&gt;.
 The metamethod is looked up in &lt;code&gt;table&lt;/code&gt;.

<SPAN CLASS="etc">@@ -613,16 +611,18 @@</SPAN>
 Despite the name,
 the metamethod for this event can be either a function or a table.
 If it is a function,
<SPAN CLASS="del">-it is called with &lt;code&gt;table&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; as arguments.</SPAN>
<SPAN CLASS="add">+it is called with &lt;code&gt;table&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; as arguments,</SPAN>
<SPAN CLASS="add">+and the result of the call</SPAN>
<SPAN CLASS="add">+(adjusted to one value)</SPAN>
<SPAN CLASS="add">+is the result of the operation.</SPAN>
 If it is a table,
 the final result is the result of indexing this table with &lt;code&gt;key&lt;/code&gt;.
 (This indexing is regular, not raw,
 and therefore can trigger another metamethod.)
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"newindex": &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__newindex&lt;/code&gt;: &lt;/b&gt;</SPAN>
 The indexing assignment &lt;code&gt;table[key] = value&lt;/code&gt;.
<SPAN CLASS="del">-</SPAN>
 Like the index event,
 this event happens when &lt;code&gt;table&lt;/code&gt; is not a table or
 when &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;table&lt;/code&gt;.

<SPAN CLASS="etc">@@ -641,22 +641,24 @@</SPAN>
 
 
 &lt;p&gt;
<SPAN CLASS="del">-Whenever there is a "newindex" metamethod,</SPAN>
<SPAN CLASS="add">+Whenever there is a &lt;code&gt;__newindex&lt;/code&gt; metamethod,</SPAN>
 Lua does not perform the primitive assignment.
 (If necessary,
 the metamethod itself can call &lt;a href="#pdf-rawset"&gt;&lt;code&gt;rawset&lt;/code&gt;&lt;/a&gt;
 to do the assignment.)
 &lt;/li&gt;
 
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;"call": &lt;/b&gt;</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;__call&lt;/code&gt;: &lt;/b&gt;</SPAN>
 The call operation &lt;code&gt;func(args)&lt;/code&gt;.
<SPAN CLASS="del">-</SPAN>
 This event happens when Lua tries to call a non-function value
 (that is, &lt;code&gt;func&lt;/code&gt; is not a function).
 The metamethod is looked up in &lt;code&gt;func&lt;/code&gt;.
 If present,
 the metamethod is called with &lt;code&gt;func&lt;/code&gt; as its first argument,
 followed by the arguments of the original call (&lt;code&gt;args&lt;/code&gt;).
<SPAN CLASS="add">+All results of the call</SPAN>
<SPAN CLASS="add">+are the result of the operation.</SPAN>
<SPAN CLASS="add">+(This is the only metamethod that allows multiple results.)</SPAN>
 &lt;/li&gt;
 
 &lt;/ul&gt;

<SPAN CLASS="etc">@@ -664,10 +666,19 @@</SPAN>
 &lt;p&gt;
 It is a good practice to add all needed metamethods to a table
 before setting it as a metatable of some object.
<SPAN CLASS="del">-In particular, the "&lt;code&gt;__gc&lt;/code&gt;" metamethod works only when this order</SPAN>
<SPAN CLASS="add">+In particular, the &lt;code&gt;__gc&lt;/code&gt; metamethod works only when this order</SPAN>
 is followed (see &lt;a href="#2.5.1"&gt;&amp;sect;2.5.1&lt;/a&gt;).
 
 
<SPAN CLASS="add">+&lt;p&gt;</SPAN>
<SPAN CLASS="add">+Because metatables are regular tables,</SPAN>
<SPAN CLASS="add">+they can contain arbitrary fields,</SPAN>
<SPAN CLASS="add">+not only the event names defined above.</SPAN>
<SPAN CLASS="add">+Some functions in the standard library</SPAN>
<SPAN CLASS="add">+(e.g., &lt;a href="#pdf-tostring"&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;)</SPAN>
<SPAN CLASS="add">+use other fields in metatables for their own purposes.</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
 
 
 

<SPAN CLASS="etc">@@ -935,7 +946,7 @@</SPAN>
 &lt;a href="#pdf-coroutine.resume"&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns &lt;b&gt;true&lt;/b&gt;,
 plus any values returned by the coroutine main function.
 In case of errors, &lt;a href="#pdf-coroutine.resume"&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns &lt;b&gt;false&lt;/b&gt;
<SPAN CLASS="del">-plus an error message.</SPAN>
<SPAN CLASS="add">+plus an error object.</SPAN>
 
 
 &lt;p&gt;

<SPAN CLASS="etc">@@ -1168,7 +1179,7 @@</SPAN>
 some control characters.
 So, it is safer to represent
 non-text data as a quoted literal with
<SPAN CLASS="del">-explicit escape sequences for non-text characters.</SPAN>
<SPAN CLASS="add">+explicit escape sequences for the non-text characters.</SPAN>
 
 
 &lt;p&gt;

<SPAN CLASS="etc">@@ -1201,9 +1212,11 @@</SPAN>
 Hexadecimal constants also accept an optional fractional part
 plus an optional binary exponent,
 marked by a letter '&lt;code&gt;p&lt;/code&gt;' or '&lt;code&gt;P&lt;/code&gt;'.
<SPAN CLASS="del">-A numeric constant with a fractional dot or an exponent </SPAN>
<SPAN CLASS="add">+A numeric constant with a radix point or an exponent </SPAN>
 denotes a float;
<SPAN CLASS="del">-otherwise it denotes an integer.</SPAN>
<SPAN CLASS="add">+otherwise,</SPAN>
<SPAN CLASS="add">+if its value fits in an integer,</SPAN>
<SPAN CLASS="add">+it denotes an integer.</SPAN>
 Examples of valid integer constants are
 
 &lt;pre&gt;

<SPAN CLASS="etc">@@ -1794,7 +1807,7 @@</SPAN>
 relational operators (see &lt;a href="#3.4.4"&gt;&amp;sect;3.4.4&lt;/a&gt;), logical operators (see &lt;a href="#3.4.5"&gt;&amp;sect;3.4.5&lt;/a&gt;),
 and the concatenation operator (see &lt;a href="#3.4.6"&gt;&amp;sect;3.4.6&lt;/a&gt;).
 Unary operators comprise the unary minus (see &lt;a href="#3.4.1"&gt;&amp;sect;3.4.1&lt;/a&gt;),
<SPAN CLASS="del">-the unary bitwise not (see &lt;a href="#3.4.2"&gt;&amp;sect;3.4.2&lt;/a&gt;),</SPAN>
<SPAN CLASS="add">+the unary bitwise NOT (see &lt;a href="#3.4.2"&gt;&amp;sect;3.4.2&lt;/a&gt;),</SPAN>
 the unary logical &lt;b&gt;not&lt;/b&gt; (see &lt;a href="#3.4.5"&gt;&amp;sect;3.4.5&lt;/a&gt;),
 and the unary &lt;em&gt;length operator&lt;/em&gt; (see &lt;a href="#3.4.7"&gt;&amp;sect;3.4.7&lt;/a&gt;).
 

<SPAN CLASS="etc">@@ -1908,12 +1921,12 @@</SPAN>
 Lua supports the following bitwise operators:
 
 &lt;ul&gt;
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;: &lt;/b&gt;bitwise and&lt;/li&gt;</SPAN>
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;&lt;code&gt;&amp;#124;&lt;/code&gt;: &lt;/b&gt;bitwise or&lt;/li&gt;</SPAN>
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;&lt;code&gt;~&lt;/code&gt;: &lt;/b&gt;bitwise exclusive or&lt;/li&gt;</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;: &lt;/b&gt;bitwise AND&lt;/li&gt;</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;&amp;#124;&lt;/code&gt;: &lt;/b&gt;bitwise OR&lt;/li&gt;</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;~&lt;/code&gt;: &lt;/b&gt;bitwise exclusive OR&lt;/li&gt;</SPAN>
 &lt;li&gt;&lt;b&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;: &lt;/b&gt;right shift&lt;/li&gt;
 &lt;li&gt;&lt;b&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;: &lt;/b&gt;left shift&lt;/li&gt;
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;&lt;code&gt;~&lt;/code&gt;: &lt;/b&gt;unary bitwise not&lt;/li&gt;</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;code&gt;~&lt;/code&gt;: &lt;/b&gt;unary bitwise NOT&lt;/li&gt;</SPAN>
 &lt;/ul&gt;
 
 &lt;p&gt;

<SPAN CLASS="etc">@@ -1984,6 +1997,13 @@</SPAN>
 
 
 &lt;p&gt;
<SPAN CLASS="add">+All conversions from strings to numbers </SPAN>
<SPAN CLASS="add">+accept both a dot and the current locale mark</SPAN>
<SPAN CLASS="add">+as the radix character.</SPAN>
<SPAN CLASS="add">+(The Lua lexer, however, accepts only a dot.)</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+&lt;p&gt;</SPAN>
 The conversion from numbers to strings uses a
 non-specified human-readable format.
 For complete control over how numbers are converted to strings,

<SPAN CLASS="etc">@@ -2792,7 +2812,7 @@</SPAN>
 
 &lt;p&gt;
 The panic function runs as if it were a message handler (see &lt;a href="#2.3"&gt;&amp;sect;2.3&lt;/a&gt;);
<SPAN CLASS="del">-in particular, the error message is at the top of the stack.</SPAN>
<SPAN CLASS="add">+in particular, the error object is at the top of the stack.</SPAN>
 However, there is no guarantee about stack space.
 To push anything on the stack,
 the panic function must first check the available space (see &lt;a href="#4.2"&gt;&amp;sect;4.2&lt;/a&gt;).

<SPAN CLASS="etc">@@ -2974,8 +2994,11 @@</SPAN>
 The third field, &lt;code&gt;x&lt;/code&gt;,
 tells whether the function may raise errors:
 '&lt;code&gt;-&lt;/code&gt;' means the function never raises any error;
<SPAN CLASS="del">-'&lt;code&gt;m&lt;/code&gt;' means the function may raise memory errors;</SPAN>
<SPAN CLASS="del">-'&lt;code&gt;e&lt;/code&gt;' means the function may raise errors;</SPAN>
<SPAN CLASS="add">+'&lt;code&gt;m&lt;/code&gt;' means the function may raise out-of-memory errors</SPAN>
<SPAN CLASS="add">+and errors running a &lt;code&gt;__gc&lt;/code&gt; metamethod;</SPAN>
<SPAN CLASS="add">+'&lt;code&gt;e&lt;/code&gt;' means the function may raise any errors</SPAN>
<SPAN CLASS="add">+(it can run arbitrary Lua code,</SPAN>
<SPAN CLASS="add">+either directly or through metamethods);</SPAN>
 '&lt;code&gt;v&lt;/code&gt;' means the function may raise an error on purpose.
 
 

<SPAN CLASS="etc">@@ -3102,10 +3125,10 @@</SPAN>
 &lt;li&gt;&lt;b&gt;&lt;a name="pdf-LUA_OPMOD"&gt;&lt;code&gt;LUA_OPMOD&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs modulo (&lt;code&gt;%&lt;/code&gt;)&lt;/li&gt;
 &lt;li&gt;&lt;b&gt;&lt;a name="pdf-LUA_OPPOW"&gt;&lt;code&gt;LUA_OPPOW&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs exponentiation (&lt;code&gt;^&lt;/code&gt;)&lt;/li&gt;
 &lt;li&gt;&lt;b&gt;&lt;a name="pdf-LUA_OPUNM"&gt;&lt;code&gt;LUA_OPUNM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs mathematical negation (unary &lt;code&gt;-&lt;/code&gt;)&lt;/li&gt;
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;&lt;a name="pdf-LUA_OPBNOT"&gt;&lt;code&gt;LUA_OPBNOT&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise negation (&lt;code&gt;~&lt;/code&gt;)&lt;/li&gt;</SPAN>
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;&lt;a name="pdf-LUA_OPBAND"&gt;&lt;code&gt;LUA_OPBAND&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise and (&lt;code&gt;&amp;amp;&lt;/code&gt;)&lt;/li&gt;</SPAN>
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;&lt;a name="pdf-LUA_OPBOR"&gt;&lt;code&gt;LUA_OPBOR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise or (&lt;code&gt;|&lt;/code&gt;)&lt;/li&gt;</SPAN>
<SPAN CLASS="del">-&lt;li&gt;&lt;b&gt;&lt;a name="pdf-LUA_OPBXOR"&gt;&lt;code&gt;LUA_OPBXOR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise exclusive or (&lt;code&gt;~&lt;/code&gt;)&lt;/li&gt;</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;a name="pdf-LUA_OPBNOT"&gt;&lt;code&gt;LUA_OPBNOT&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise NOT (&lt;code&gt;~&lt;/code&gt;)&lt;/li&gt;</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;a name="pdf-LUA_OPBAND"&gt;&lt;code&gt;LUA_OPBAND&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise AND (&lt;code&gt;&amp;amp;&lt;/code&gt;)&lt;/li&gt;</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;a name="pdf-LUA_OPBOR"&gt;&lt;code&gt;LUA_OPBOR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise OR (&lt;code&gt;|&lt;/code&gt;)&lt;/li&gt;</SPAN>
<SPAN CLASS="add">+&lt;li&gt;&lt;b&gt;&lt;a name="pdf-LUA_OPBXOR"&gt;&lt;code&gt;LUA_OPBXOR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise exclusive OR (&lt;code&gt;~&lt;/code&gt;)&lt;/li&gt;</SPAN>
 &lt;li&gt;&lt;b&gt;&lt;a name="pdf-LUA_OPSHL"&gt;&lt;code&gt;LUA_OPSHL&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs left shift (&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;)&lt;/li&gt;
 &lt;li&gt;&lt;b&gt;&lt;a name="pdf-LUA_OPSHR"&gt;&lt;code&gt;LUA_OPSHR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs right shift (&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;)&lt;/li&gt;
 

<SPAN CLASS="etc">@@ -3424,7 +3447,7 @@</SPAN>
 
 
 &lt;hr&gt;&lt;h3&gt;&lt;a name="lua_gc"&gt;&lt;code&gt;lua_gc&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;
<SPAN CLASS="del">-&lt;span class="apii"&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]&lt;/span&gt;</SPAN>
<SPAN CLASS="add">+&lt;span class="apii"&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]&lt;/span&gt;</SPAN>
 &lt;pre&gt;int lua_gc (lua_State *L, int what, int data);&lt;/pre&gt;
 
 &lt;p&gt;

<SPAN CLASS="etc">@@ -3919,7 +3942,7 @@</SPAN>
 syntax error during precompilation;&lt;/li&gt;
 
 &lt;li&gt;&lt;b&gt;&lt;a href="#pdf-LUA_ERRMEM"&gt;&lt;code&gt;LUA_ERRMEM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt;
<SPAN CLASS="del">-memory allocation error;&lt;/li&gt;</SPAN>
<SPAN CLASS="add">+memory allocation (out-of-memory) error;&lt;/li&gt;</SPAN>
 
 &lt;li&gt;&lt;b&gt;&lt;a href="#pdf-LUA_ERRGCMM"&gt;&lt;code&gt;LUA_ERRGCMM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt;
 error while running a &lt;code&gt;__gc&lt;/code&gt; metamethod.

<SPAN CLASS="etc">@@ -4128,7 +4151,7 @@</SPAN>
 &lt;a href="#lua_pcall"&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; behaves exactly like &lt;a href="#lua_call"&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;.
 However, if there is any error,
 &lt;a href="#lua_pcall"&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; catches it,
<SPAN CLASS="del">-pushes a single value on the stack (the error message),</SPAN>
<SPAN CLASS="add">+pushes a single value on the stack (the error object),</SPAN>
 and returns an error code.
 Like &lt;a href="#lua_call"&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;,
 &lt;a href="#lua_pcall"&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; always removes the function

<SPAN CLASS="etc">@@ -4137,20 +4160,20 @@</SPAN>
 
 &lt;p&gt;
 If &lt;code&gt;msgh&lt;/code&gt; is 0,
<SPAN CLASS="del">-then the error message returned on the stack</SPAN>
<SPAN CLASS="del">-is exactly the original error message.</SPAN>
<SPAN CLASS="add">+then the error object returned on the stack</SPAN>
<SPAN CLASS="add">+is exactly the original error object.</SPAN>
 Otherwise, &lt;code&gt;msgh&lt;/code&gt; is the stack index of a
 &lt;em&gt;message handler&lt;/em&gt;.
 (This index cannot be a pseudo-index.)
 In case of runtime errors,
<SPAN CLASS="del">-this function will be called with the error message</SPAN>
<SPAN CLASS="del">-and its return value will be the message</SPAN>
<SPAN CLASS="add">+this function will be called with the error object</SPAN>
<SPAN CLASS="add">+and its return value will be the object</SPAN>
 returned on the stack by &lt;a href="#lua_pcall"&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;.
 
 
 &lt;p&gt;
 Typically, the message handler is used to add more debug
<SPAN CLASS="del">-information to the error message, such as a stack traceback.</SPAN>
<SPAN CLASS="add">+information to the error object, such as a stack traceback.</SPAN>
 Such information cannot be gathered after the return of &lt;a href="#lua_pcall"&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;,
 since by then the stack has unwound.
 

<SPAN CLASS="etc">@@ -4284,7 +4307,7 @@</SPAN>
 
 
 &lt;hr&gt;&lt;h3&gt;&lt;a name="lua_pushfstring"&gt;&lt;code&gt;lua_pushfstring&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;
<SPAN CLASS="del">-&lt;span class="apii"&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]&lt;/span&gt;</SPAN>
<SPAN CLASS="add">+&lt;span class="apii"&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]&lt;/span&gt;</SPAN>
 &lt;pre&gt;const char *lua_pushfstring (lua_State *L, const char *fmt, ...);&lt;/pre&gt;
 
 &lt;p&gt;

<SPAN CLASS="etc">@@ -4317,6 +4340,12 @@</SPAN>
 
 &lt;/ul&gt;
 
<SPAN CLASS="add">+&lt;p&gt;</SPAN>
<SPAN CLASS="add">+Unlike other push functions,</SPAN>
<SPAN CLASS="add">+this function checks for the stack space it needs,</SPAN>
<SPAN CLASS="add">+including the slot for its result.</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
 
 
 

<SPAN CLASS="etc">@@ -4486,7 +4515,7 @@</SPAN>
 &lt;p&gt;
 Returns 1 if the two values in indices &lt;code&gt;index1&lt;/code&gt; and
 &lt;code&gt;index2&lt;/code&gt; are primitively equal
<SPAN CLASS="del">-(that is, without calling metamethods).</SPAN>
<SPAN CLASS="add">+(that is, without calling the &lt;code&gt;__eq&lt;/code&gt; metamethod).</SPAN>
 Otherwise returns&amp;nbsp;0.
 Also returns&amp;nbsp;0 if any of the indices are not valid.
 

<SPAN CLASS="etc">@@ -4513,8 +4542,8 @@</SPAN>
 &lt;p&gt;
 Pushes onto the stack the value &lt;code&gt;t[n]&lt;/code&gt;,
 where &lt;code&gt;t&lt;/code&gt; is the table at the given index.
<SPAN CLASS="del">-The access is raw;</SPAN>
<SPAN CLASS="del">-that is, it does not invoke metamethods.</SPAN>
<SPAN CLASS="add">+The access is raw,</SPAN>
<SPAN CLASS="add">+that is, it does not invoke the &lt;code&gt;__index&lt;/code&gt; metamethod.</SPAN>
 
 
 &lt;p&gt;

<SPAN CLASS="etc">@@ -4533,7 +4562,7 @@</SPAN>
 where &lt;code&gt;t&lt;/code&gt; is the table at the given index and
 &lt;code&gt;k&lt;/code&gt; is the pointer &lt;code&gt;p&lt;/code&gt; represented as a light userdata.
 The access is raw;
<SPAN CLASS="del">-that is, it does not invoke metamethods.</SPAN>
<SPAN CLASS="add">+that is, it does not invoke the &lt;code&gt;__index&lt;/code&gt; metamethod.</SPAN>
 
 
 &lt;p&gt;

<SPAN CLASS="etc">@@ -4584,8 +4613,8 @@</SPAN>
 
 &lt;p&gt;
 This function pops the value from the stack.
<SPAN CLASS="del">-The assignment is raw;</SPAN>
<SPAN CLASS="del">-that is, it does not invoke metamethods.</SPAN>
<SPAN CLASS="add">+The assignment is raw,</SPAN>
<SPAN CLASS="add">+that is, it does not invoke the &lt;code&gt;__newindex&lt;/code&gt; metamethod.</SPAN>
 
 
 

<SPAN CLASS="etc">@@ -4604,8 +4633,8 @@</SPAN>
 
 &lt;p&gt;
 This function pops the value from the stack.
<SPAN CLASS="del">-The assignment is raw;</SPAN>
<SPAN CLASS="del">-that is, it does not invoke metamethods.</SPAN>
<SPAN CLASS="add">+The assignment is raw,</SPAN>
<SPAN CLASS="add">+that is, it does not invoke &lt;code&gt;__newindex&lt;/code&gt; metamethod.</SPAN>
 
 
 

<SPAN CLASS="etc">@@ -4704,7 +4733,7 @@</SPAN>
 In case of errors,
 the stack is not unwound,
 so you can use the debug API over it.
<SPAN CLASS="del">-The error message is on the top of the stack.</SPAN>
<SPAN CLASS="add">+The error object is on the top of the stack.</SPAN>
 
 
 &lt;p&gt;

<SPAN CLASS="etc">@@ -5179,11 +5208,13 @@</SPAN>
 
 
 &lt;hr&gt;&lt;h3&gt;&lt;a name="lua_version"&gt;&lt;code&gt;lua_version&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;
<SPAN CLASS="del">-&lt;span class="apii"&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]&lt;/span&gt;</SPAN>
<SPAN CLASS="add">+&lt;span class="apii"&gt;[-0, +0, &amp;ndash;]&lt;/span&gt;</SPAN>
 &lt;pre&gt;const lua_Number *lua_version (lua_State *L);&lt;/pre&gt;
 
 &lt;p&gt;
<SPAN CLASS="del">-Returns the address of the version number stored in the Lua core.</SPAN>
<SPAN CLASS="add">+Returns the address of the version number</SPAN>
<SPAN CLASS="add">+(a C static variable)</SPAN>
<SPAN CLASS="add">+stored in the Lua core.</SPAN>
 When called with a valid &lt;a href="#lua_State"&gt;&lt;code&gt;lua_State&lt;/code&gt;&lt;/a&gt;,
 returns the address of the version used to create that state.
 When called with &lt;code&gt;NULL&lt;/code&gt;,

<SPAN CLASS="etc">@@ -5287,9 +5318,9 @@</SPAN>
 it continues executing the continuation function.
 However, there is one special case,
 which is when this function is called
<SPAN CLASS="del">-from inside a line hook (see &lt;a href="#4.9"&gt;&amp;sect;4.9&lt;/a&gt;).</SPAN>
<SPAN CLASS="add">+from inside a line or a count hook (see &lt;a href="#4.9"&gt;&amp;sect;4.9&lt;/a&gt;).</SPAN>
 In that case, &lt;code&gt;lua_yieldk&lt;/code&gt; should be called with no continuation
<SPAN CLASS="del">-(probably in the form of &lt;a href="#lua_yield"&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;),</SPAN>
<SPAN CLASS="add">+(probably in the form of &lt;a href="#lua_yield"&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;) and no results,</SPAN>
 and the hook should return immediately after the call.
 Lua will yield and,
 when the coroutine resumes again,

<SPAN CLASS="etc">@@ -5704,7 +5735,7 @@</SPAN>
 &lt;p&gt;
 Argument &lt;code&gt;f&lt;/code&gt; is the hook function.
 &lt;code&gt;mask&lt;/code&gt; specifies on which events the hook will be called:
<SPAN CLASS="del">-it is formed by a bitwise or of the constants</SPAN>
<SPAN CLASS="add">+it is formed by a bitwise OR of the constants</SPAN>
 &lt;a name="pdf-LUA_MASKCALL"&gt;&lt;code&gt;LUA_MASKCALL&lt;/code&gt;&lt;/a&gt;,
 &lt;a name="pdf-LUA_MASKRET"&gt;&lt;code&gt;LUA_MASKRET&lt;/code&gt;&lt;/a&gt;,
 &lt;a name="pdf-LUA_MASKLINE"&gt;&lt;code&gt;LUA_MASKLINE&lt;/code&gt;&lt;/a&gt;,

<SPAN CLASS="etc">@@ -6256,7 +6287,7 @@</SPAN>
 
 
 &lt;hr&gt;&lt;h3&gt;&lt;a name="luaL_checkversion"&gt;&lt;code&gt;luaL_checkversion&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;
<SPAN CLASS="del">-&lt;span class="apii"&gt;[-0, +0, &amp;ndash;]&lt;/span&gt;</SPAN>
<SPAN CLASS="add">+&lt;span class="apii"&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]&lt;/span&gt;</SPAN>
 &lt;pre&gt;void luaL_checkversion (lua_State *L);&lt;/pre&gt;
 
 &lt;p&gt;

<SPAN CLASS="etc">@@ -6472,7 +6503,7 @@</SPAN>
 
 
 &lt;hr&gt;&lt;h3&gt;&lt;a name="luaL_loadfile"&gt;&lt;code&gt;luaL_loadfile&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;
<SPAN CLASS="del">-&lt;span class="apii"&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]&lt;/span&gt;</SPAN>
<SPAN CLASS="add">+&lt;span class="apii"&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]&lt;/span&gt;</SPAN>
 &lt;pre&gt;int luaL_loadfile (lua_State *L, const char *filename);&lt;/pre&gt;
 
 &lt;p&gt;

<SPAN CLASS="etc">@@ -6483,7 +6514,7 @@</SPAN>
 
 
 &lt;hr&gt;&lt;h3&gt;&lt;a name="luaL_loadfilex"&gt;&lt;code&gt;luaL_loadfilex&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;
<SPAN CLASS="del">-&lt;span class="apii"&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]&lt;/span&gt;</SPAN>
<SPAN CLASS="add">+&lt;span class="apii"&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]&lt;/span&gt;</SPAN>
 &lt;pre&gt;int luaL_loadfilex (lua_State *L, const char *filename,
                                             const char *mode);&lt;/pre&gt;
 

<SPAN CLASS="etc">@@ -6634,6 +6665,27 @@</SPAN>
 
 
 
<SPAN CLASS="add">+&lt;hr&gt;&lt;h3&gt;&lt;a name="luaL_opt"&gt;&lt;code&gt;luaL_opt&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;</SPAN>
<SPAN CLASS="add">+&lt;span class="apii"&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]&lt;/span&gt;</SPAN>
<SPAN CLASS="add">+&lt;pre&gt;T luaL_opt (L, func, arg, dflt);&lt;/pre&gt;</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+&lt;p&gt;</SPAN>
<SPAN CLASS="add">+This macro is defined as follows:</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+&lt;pre&gt;</SPAN>
<SPAN CLASS="add">+     (lua_isnoneornil(L,(arg)) ? (dflt) : func(L,(arg)))</SPAN>
<SPAN CLASS="add">+&lt;/pre&gt;&lt;p&gt;</SPAN>
<SPAN CLASS="add">+In words, if the argument &lt;code&gt;arg&lt;/code&gt; is nil or absent,</SPAN>
<SPAN CLASS="add">+the macro results in the default &lt;code&gt;dflt&lt;/code&gt;.</SPAN>
<SPAN CLASS="add">+Otherwise, it results in the result of calling &lt;code&gt;func&lt;/code&gt;</SPAN>
<SPAN CLASS="add">+with the state &lt;code&gt;L&lt;/code&gt; and the argument index &lt;code&gt;arg&lt;/code&gt; as</SPAN>
<SPAN CLASS="add">+parameters.</SPAN>
<SPAN CLASS="add">+Note that it evaluates the expression &lt;code&gt;dflt&lt;/code&gt; only if needed.</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
 &lt;hr&gt;&lt;h3&gt;&lt;a name="luaL_optinteger"&gt;&lt;code&gt;luaL_optinteger&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;
 &lt;span class="apii"&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]&lt;/span&gt;
 &lt;pre&gt;lua_Integer luaL_optinteger (lua_State *L,

<SPAN CLASS="etc">@@ -6931,7 +6983,7 @@</SPAN>
 
 
 &lt;p&gt;
<SPAN CLASS="del">-If the value has a metatable with a &lt;code&gt;"__tostring"&lt;/code&gt; field,</SPAN>
<SPAN CLASS="add">+If the value has a metatable with a &lt;code&gt;__tostring&lt;/code&gt; field,</SPAN>
 then &lt;code&gt;luaL_tolstring&lt;/code&gt; calls the corresponding metamethod
 with the value as argument,
 and uses the result of the call as its result.

<SPAN CLASS="etc">@@ -7220,7 +7272,7 @@</SPAN>
 &lt;p&gt;
 If &lt;code&gt;object&lt;/code&gt; does not have a metatable, returns &lt;b&gt;nil&lt;/b&gt;.
 Otherwise,
<SPAN CLASS="del">-if the object's metatable has a &lt;code&gt;"__metatable"&lt;/code&gt; field,</SPAN>
<SPAN CLASS="add">+if the object's metatable has a &lt;code&gt;__metatable&lt;/code&gt; field,</SPAN>
 returns the associated value.
 Otherwise, returns the metatable of the given object.
 

<SPAN CLASS="etc">@@ -7424,7 +7476,7 @@</SPAN>
 &lt;p&gt;
 &lt;hr&gt;&lt;h3&gt;&lt;a name="pdf-rawequal"&gt;&lt;code&gt;rawequal (v1, v2)&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;
 Checks whether &lt;code&gt;v1&lt;/code&gt; is equal to &lt;code&gt;v2&lt;/code&gt;,
<SPAN CLASS="del">-without invoking any metamethod.</SPAN>
<SPAN CLASS="add">+without invoking the &lt;code&gt;__eq&lt;/code&gt; metamethod.</SPAN>
 Returns a boolean.
 
 

<SPAN CLASS="etc">@@ -7433,7 +7485,7 @@</SPAN>
 &lt;p&gt;
 &lt;hr&gt;&lt;h3&gt;&lt;a name="pdf-rawget"&gt;&lt;code&gt;rawget (table, index)&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;
 Gets the real value of &lt;code&gt;table[index]&lt;/code&gt;,
<SPAN CLASS="del">-without invoking any metamethod.</SPAN>
<SPAN CLASS="add">+without invoking the &lt;code&gt;__index&lt;/code&gt; metamethod.</SPAN>
 &lt;code&gt;table&lt;/code&gt; must be a table;
 &lt;code&gt;index&lt;/code&gt; may be any value.
 

<SPAN CLASS="etc">@@ -7444,7 +7496,7 @@</SPAN>
 &lt;hr&gt;&lt;h3&gt;&lt;a name="pdf-rawlen"&gt;&lt;code&gt;rawlen (v)&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;
 Returns the length of the object &lt;code&gt;v&lt;/code&gt;,
 which must be a table or a string,
<SPAN CLASS="del">-without invoking any metamethod.</SPAN>
<SPAN CLASS="add">+without invoking the &lt;code&gt;__len&lt;/code&gt; metamethod.</SPAN>
 Returns an integer.
 
 

<SPAN CLASS="etc">@@ -7453,7 +7505,7 @@</SPAN>
 &lt;p&gt;
 &lt;hr&gt;&lt;h3&gt;&lt;a name="pdf-rawset"&gt;&lt;code&gt;rawset (table, index, value)&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;
 Sets the real value of &lt;code&gt;table[index]&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;,
<SPAN CLASS="del">-without invoking any metamethod.</SPAN>
<SPAN CLASS="add">+without invoking the &lt;code&gt;__newindex&lt;/code&gt; metamethod.</SPAN>
 &lt;code&gt;table&lt;/code&gt; must be a table,
 &lt;code&gt;index&lt;/code&gt; any value different from &lt;b&gt;nil&lt;/b&gt; and NaN,
 and &lt;code&gt;value&lt;/code&gt; any Lua value.

<SPAN CLASS="etc">@@ -7489,7 +7541,7 @@</SPAN>
 you must use the debug library (&lt;a href="#6.10"&gt;&amp;sect;6.10&lt;/a&gt;).)
 If &lt;code&gt;metatable&lt;/code&gt; is &lt;b&gt;nil&lt;/b&gt;,
 removes the metatable of the given table.
<SPAN CLASS="del">-If the original metatable has a &lt;code&gt;"__metatable"&lt;/code&gt; field,</SPAN>
<SPAN CLASS="add">+If the original metatable has a &lt;code&gt;__metatable&lt;/code&gt; field,</SPAN>
 raises an error.
 
 

<SPAN CLASS="etc">@@ -7541,7 +7593,7 @@</SPAN>
 
 
 &lt;p&gt;
<SPAN CLASS="del">-If the metatable of &lt;code&gt;v&lt;/code&gt; has a &lt;code&gt;"__tostring"&lt;/code&gt; field,</SPAN>
<SPAN CLASS="add">+If the metatable of &lt;code&gt;v&lt;/code&gt; has a &lt;code&gt;__tostring&lt;/code&gt; field,</SPAN>
 then &lt;code&gt;tostring&lt;/code&gt; calls the corresponding value
 with &lt;code&gt;v&lt;/code&gt; as argument,
 and uses the result of the call as its result.

<SPAN CLASS="etc">@@ -8184,6 +8236,9 @@</SPAN>
 &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;,
 and &lt;code&gt;p&lt;/code&gt; are not supported
 and that there is an extra option, &lt;code&gt;q&lt;/code&gt;.
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+&lt;p&gt;</SPAN>
 The &lt;code&gt;q&lt;/code&gt; option formats a string between double quotes,
 using escape sequences when necessary to ensure that
 it can safely be read back by the Lua interpreter.

<SPAN CLASS="etc">@@ -8206,7 +8261,12 @@</SPAN>
 Options &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;,
 &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt;
 expect an integer.
<SPAN CLASS="del">-Option &lt;code&gt;q&lt;/code&gt; expects a string.</SPAN>
<SPAN CLASS="add">+When Lua is compiled with a C89 compiler,</SPAN>
<SPAN CLASS="add">+options &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; (hexadecimal floats)</SPAN>
<SPAN CLASS="add">+do not support any modifier (flags, width, length).</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+&lt;p&gt;</SPAN>
 Option &lt;code&gt;s&lt;/code&gt; expects a string;
 if its argument is not a string,
 it is converted to one following the same rules of &lt;a href="#pdf-tostring"&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;.

<SPAN CLASS="etc">@@ -8214,12 +8274,6 @@</SPAN>
 the string argument should not contain embedded zeros.
 
 
<SPAN CLASS="del">-&lt;p&gt;</SPAN>
<SPAN CLASS="del">-When Lua is compiled with a non-C99 compiler,</SPAN>
<SPAN CLASS="del">-options &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; (hexadecimal floats)</SPAN>
<SPAN CLASS="del">-do not support any modifier (flags, width, length).</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-</SPAN>
 
 
 &lt;p&gt;

<SPAN CLASS="etc">@@ -8548,6 +8602,14 @@</SPAN>
 
 
 &lt;p&gt;
<SPAN CLASS="add">+You can put a closing square bracket in a set</SPAN>
<SPAN CLASS="add">+by positioning it as the first character in the set.</SPAN>
<SPAN CLASS="add">+You can put an hyphen in a set</SPAN>
<SPAN CLASS="add">+by positioning it as the first or the last character in the set.</SPAN>
<SPAN CLASS="add">+(You can also use an escape for both cases.)</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+&lt;p&gt;</SPAN>
 The interaction between ranges and classes is not defined.
 Therefore, patterns like &lt;code&gt;[%a-z]&lt;/code&gt; or &lt;code&gt;[a-%%]&lt;/code&gt;
 have no meaning.

<SPAN CLASS="etc">@@ -8925,8 +8987,8 @@</SPAN>
 
 
 &lt;p&gt;
<SPAN CLASS="del">-Moves elements from table &lt;code&gt;a1&lt;/code&gt; to table &lt;code&gt;a2&lt;/code&gt;.</SPAN>
<SPAN CLASS="del">-This function performs the equivalent to the following</SPAN>
<SPAN CLASS="add">+Moves elements from table &lt;code&gt;a1&lt;/code&gt; to table &lt;code&gt;a2&lt;/code&gt;,</SPAN>
<SPAN CLASS="add">+performing the equivalent to the following</SPAN>
 multiple assignment:
 &lt;code&gt;a2[t],&amp;middot;&amp;middot;&amp;middot; = a1[f],&amp;middot;&amp;middot;&amp;middot;,a1[e]&lt;/code&gt;.
 The default for &lt;code&gt;a2&lt;/code&gt; is &lt;code&gt;a1&lt;/code&gt;.

<SPAN CLASS="etc">@@ -8934,6 +8996,10 @@</SPAN>
 The number of elements to be moved must fit in a Lua integer.
 
 
<SPAN CLASS="add">+&lt;p&gt;</SPAN>
<SPAN CLASS="add">+Returns the destination table &lt;code&gt;a2&lt;/code&gt;.</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
 
 
 &lt;p&gt;

<SPAN CLASS="etc">@@ -9457,8 +9523,8 @@</SPAN>
 &lt;p&gt;
 This function opens a file,
 in the mode specified in the string &lt;code&gt;mode&lt;/code&gt;.
<SPAN CLASS="del">-It returns a new file handle,</SPAN>
<SPAN CLASS="del">-or, in case of errors, &lt;b&gt;nil&lt;/b&gt; plus an error message.</SPAN>
<SPAN CLASS="add">+In case of success,</SPAN>
<SPAN CLASS="add">+it returns a new file handle.</SPAN>
 
 
 &lt;p&gt;

<SPAN CLASS="etc">@@ -9523,7 +9589,8 @@</SPAN>
 
 
 &lt;p&gt;
<SPAN CLASS="del">-Returns a handle for a temporary file.</SPAN>
<SPAN CLASS="add">+In case of success,</SPAN>
<SPAN CLASS="add">+returns a handle for a temporary file.</SPAN>
 This file is opened in update mode
 and it is automatically removed when the program ends.
 

<SPAN CLASS="etc">@@ -9801,8 +9868,8 @@</SPAN>
 then &lt;code&gt;date&lt;/code&gt; returns a table with the following fields:
 &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt; (1&amp;ndash;12), &lt;code&gt;day&lt;/code&gt; (1&amp;ndash;31),
 &lt;code&gt;hour&lt;/code&gt; (0&amp;ndash;23), &lt;code&gt;min&lt;/code&gt; (0&amp;ndash;59), &lt;code&gt;sec&lt;/code&gt; (0&amp;ndash;61),
<SPAN CLASS="del">-&lt;code&gt;wday&lt;/code&gt; (weekday, Sunday is&amp;nbsp;1),</SPAN>
<SPAN CLASS="del">-&lt;code&gt;yday&lt;/code&gt; (day of the year),</SPAN>
<SPAN CLASS="add">+&lt;code&gt;wday&lt;/code&gt; (weekday, 1&amp;ndash;7, Sunday is&amp;nbsp;1),</SPAN>
<SPAN CLASS="add">+&lt;code&gt;yday&lt;/code&gt; (day of the year, 1&amp;ndash;366),</SPAN>
 and &lt;code&gt;isdst&lt;/code&gt; (daylight saving flag, a boolean).
 This last field may be absent
 if the information is not available.

<SPAN CLASS="etc">@@ -10505,6 +10572,14 @@</SPAN>
 
 
 &lt;p&gt;
<SPAN CLASS="add">+If the global variable &lt;a name="pdf-_PROMPT"&gt;&lt;code&gt;_PROMPT&lt;/code&gt;&lt;/a&gt; contains a string,</SPAN>
<SPAN CLASS="add">+then its value is used as the prompt.</SPAN>
<SPAN CLASS="add">+Similarly, if the global variable &lt;a name="pdf-_PROMPT2"&gt;&lt;code&gt;_PROMPT2&lt;/code&gt;&lt;/a&gt; contains a string,</SPAN>
<SPAN CLASS="add">+its value is used as the secondary prompt</SPAN>
<SPAN CLASS="add">+(issued during incomplete statements).</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+&lt;p&gt;</SPAN>
 In case of unprotected errors in the script,
 the interpreter reports the error to the standard error stream.
 If the error object is not a string but 

<SPAN CLASS="etc">@@ -10825,10 +10900,10 @@</SPAN>
 
 &lt;P CLASS="footer"&gt;
 Last update:
<SPAN CLASS="del">-Wed Nov 25 15:19:10 BRST 2015</SPAN>
<SPAN CLASS="add">+Mon May 30 13:11:08 BRT 2016</SPAN>
 &lt;/P&gt;
 &lt;!--
<SPAN CLASS="del">-Last change: revised for Lua 5.3.2</SPAN>
<SPAN CLASS="add">+Last change: revised for Lua 5.3.3</SPAN>
 --&gt;
 
 &lt;/body&gt;&lt;/html&gt;

<SPAN CLASS="diff">doc/readme.html</SPAN>

<SPAN CLASS="etc">@@ -276,7 +276,7 @@</SPAN>
 &lt;H3&gt;Language&lt;/H3&gt;
 &lt;UL&gt;
 &lt;LI&gt; userdata can have any Lua value as uservalue
<SPAN CLASS="del">-&lt;LI&gt; integer division</SPAN>
<SPAN CLASS="add">+&lt;LI&gt; floor division</SPAN>
 &lt;LI&gt; more flexible rules for some metamethods
 &lt;/UL&gt;
 

<SPAN CLASS="etc">@@ -328,7 +328,7 @@</SPAN>
 &lt;A HREF="http://www.lua.org/license.html"&gt;this&lt;/A&gt;.
 
 &lt;BLOCKQUOTE STYLE="padding-bottom: 0em"&gt;
<SPAN CLASS="del">-Copyright &amp;copy; 1994&amp;ndash;2015 Lua.org, PUC-Rio.</SPAN>
<SPAN CLASS="add">+Copyright &amp;copy; 1994&amp;ndash;2016 Lua.org, PUC-Rio.</SPAN>
 
 &lt;P&gt;
 Permission is hereby granted, free of charge, to any person obtaining a copy

<SPAN CLASS="etc">@@ -355,10 +355,10 @@</SPAN>
 
 &lt;P CLASS="footer"&gt;
 Last update:
<SPAN CLASS="del">-Mon Jun  1 21:48:24 BRT 2015</SPAN>
<SPAN CLASS="add">+Tue Feb  2 22:25:27 BRST 2016</SPAN>
 &lt;/P&gt;
 &lt;!--
<SPAN CLASS="del">-Last change: revised for Lua 5.3.1</SPAN>
<SPAN CLASS="add">+Last change: revised for Lua 5.3.3</SPAN>
 --&gt;
 
 &lt;/BODY&gt;

<SPAN CLASS="diff">src/lapi.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lapi.c,v 2.257 2015/11/02 18:48:07 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lapi.c,v 2.259 2016/02/29 14:27:14 roberto Exp $</SPAN>
 ** Lua API
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -378,9 +378,9 @@</SPAN>
       return NULL;
     }
     lua_lock(L);  /* 'luaO_tostring' may create a new string */
<SPAN CLASS="add">+    luaO_tostring(L, o);</SPAN>
     luaC_checkGC(L);
     o = index2addr(L, idx);  /* previous call may reallocate the stack */
<SPAN CLASS="del">-    luaO_tostring(L, o);</SPAN>
     lua_unlock(L);
   }
   if (len != NULL)

<SPAN CLASS="etc">@@ -479,10 +479,10 @@</SPAN>
 LUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {
   TString *ts;
   lua_lock(L);
<SPAN CLASS="del">-  luaC_checkGC(L);</SPAN>
   ts = (len == 0) ? luaS_new(L, "") : luaS_newlstr(L, s, len);
   setsvalue2s(L, L-&gt;top, ts);
   api_incr_top(L);
<SPAN CLASS="add">+  luaC_checkGC(L);</SPAN>
   lua_unlock(L);
   return getstr(ts);
 }

<SPAN CLASS="etc">@@ -494,12 +494,12 @@</SPAN>
     setnilvalue(L-&gt;top);
   else {
     TString *ts;
<SPAN CLASS="del">-    luaC_checkGC(L);</SPAN>
     ts = luaS_new(L, s);
     setsvalue2s(L, L-&gt;top, ts);
     s = getstr(ts);  /* internal copy's address */
   }
   api_incr_top(L);
<SPAN CLASS="add">+  luaC_checkGC(L);</SPAN>
   lua_unlock(L);
   return s;
 }

<SPAN CLASS="etc">@@ -509,8 +509,8 @@</SPAN>
                                       va_list argp) {
   const char *ret;
   lua_lock(L);
<SPAN CLASS="del">-  luaC_checkGC(L);</SPAN>
   ret = luaO_pushvfstring(L, fmt, argp);
<SPAN CLASS="add">+  luaC_checkGC(L);</SPAN>
   lua_unlock(L);
   return ret;
 }

<SPAN CLASS="etc">@@ -520,10 +520,10 @@</SPAN>
   const char *ret;
   va_list argp;
   lua_lock(L);
<SPAN CLASS="del">-  luaC_checkGC(L);</SPAN>
   va_start(argp, fmt);
   ret = luaO_pushvfstring(L, fmt, argp);
   va_end(argp);
<SPAN CLASS="add">+  luaC_checkGC(L);</SPAN>
   lua_unlock(L);
   return ret;
 }

<SPAN CLASS="etc">@@ -538,7 +538,6 @@</SPAN>
     CClosure *cl;
     api_checknelems(L, n);
     api_check(L, n &lt;= MAXUPVAL, "upvalue index too large");
<SPAN CLASS="del">-    luaC_checkGC(L);</SPAN>
     cl = luaF_newCclosure(L, n);
     cl-&gt;f = fn;
     L-&gt;top -= n;

<SPAN CLASS="etc">@@ -549,6 +548,7 @@</SPAN>
     setclCvalue(L, L-&gt;top, cl);
   }
   api_incr_top(L);
<SPAN CLASS="add">+  luaC_checkGC(L);</SPAN>
   lua_unlock(L);
 }
 

<SPAN CLASS="etc">@@ -585,16 +585,16 @@</SPAN>
 
 
 static int auxgetstr (lua_State *L, const TValue *t, const char *k) {
<SPAN CLASS="del">-  const TValue *aux;</SPAN>
<SPAN CLASS="add">+  const TValue *slot;</SPAN>
   TString *str = luaS_new(L, k);
<SPAN CLASS="del">-  if (luaV_fastget(L, t, str, aux, luaH_getstr)) {</SPAN>
<SPAN CLASS="del">-    setobj2s(L, L-&gt;top, aux);</SPAN>
<SPAN CLASS="add">+  if (luaV_fastget(L, t, str, slot, luaH_getstr)) {</SPAN>
<SPAN CLASS="add">+    setobj2s(L, L-&gt;top, slot);</SPAN>
     api_incr_top(L);
   }
   else {
     setsvalue2s(L, L-&gt;top, str);
     api_incr_top(L);
<SPAN CLASS="del">-    luaV_finishget(L, t, L-&gt;top - 1, L-&gt;top - 1, aux);</SPAN>
<SPAN CLASS="add">+    luaV_finishget(L, t, L-&gt;top - 1, L-&gt;top - 1, slot);</SPAN>
   }
   lua_unlock(L);
   return ttnov(L-&gt;top - 1);

<SPAN CLASS="etc">@@ -626,17 +626,17 @@</SPAN>
 
 LUA_API int lua_geti (lua_State *L, int idx, lua_Integer n) {
   StkId t;
<SPAN CLASS="del">-  const TValue *aux;</SPAN>
<SPAN CLASS="add">+  const TValue *slot;</SPAN>
   lua_lock(L);
   t = index2addr(L, idx);
<SPAN CLASS="del">-  if (luaV_fastget(L, t, n, aux, luaH_getint)) {</SPAN>
<SPAN CLASS="del">-    setobj2s(L, L-&gt;top, aux);</SPAN>
<SPAN CLASS="add">+  if (luaV_fastget(L, t, n, slot, luaH_getint)) {</SPAN>
<SPAN CLASS="add">+    setobj2s(L, L-&gt;top, slot);</SPAN>
     api_incr_top(L);
   }
   else {
     setivalue(L-&gt;top, n);
     api_incr_top(L);
<SPAN CLASS="del">-    luaV_finishget(L, t, L-&gt;top - 1, L-&gt;top - 1, aux);</SPAN>
<SPAN CLASS="add">+    luaV_finishget(L, t, L-&gt;top - 1, L-&gt;top - 1, slot);</SPAN>
   }
   lua_unlock(L);
   return ttnov(L-&gt;top - 1);

<SPAN CLASS="etc">@@ -683,12 +683,12 @@</SPAN>
 LUA_API void lua_createtable (lua_State *L, int narray, int nrec) {
   Table *t;
   lua_lock(L);
<SPAN CLASS="del">-  luaC_checkGC(L);</SPAN>
   t = luaH_new(L);
   sethvalue(L, L-&gt;top, t);
   api_incr_top(L);
   if (narray &gt; 0 || nrec &gt; 0)
     luaH_resize(L, t, narray, nrec);
<SPAN CLASS="add">+  luaC_checkGC(L);</SPAN>
   lua_unlock(L);
 }
 

<SPAN CLASS="etc">@@ -740,15 +740,15 @@</SPAN>
 ** t[k] = value at the top of the stack (where 'k' is a string)
 */
 static void auxsetstr (lua_State *L, const TValue *t, const char *k) {
<SPAN CLASS="del">-  const TValue *aux;</SPAN>
<SPAN CLASS="add">+  const TValue *slot;</SPAN>
   TString *str = luaS_new(L, k);
   api_checknelems(L, 1);
<SPAN CLASS="del">-  if (luaV_fastset(L, t, str, aux, luaH_getstr, L-&gt;top - 1))</SPAN>
<SPAN CLASS="add">+  if (luaV_fastset(L, t, str, slot, luaH_getstr, L-&gt;top - 1))</SPAN>
     L-&gt;top--;  /* pop value */
   else {
     setsvalue2s(L, L-&gt;top, str);  /* push 'str' (to make it a TValue) */
     api_incr_top(L);
<SPAN CLASS="del">-    luaV_finishset(L, t, L-&gt;top - 1, L-&gt;top - 2, aux);</SPAN>
<SPAN CLASS="add">+    luaV_finishset(L, t, L-&gt;top - 1, L-&gt;top - 2, slot);</SPAN>
     L-&gt;top -= 2;  /* pop value and key */
   }
   lua_unlock(L);  /* lock done by caller */

<SPAN CLASS="etc">@@ -781,16 +781,16 @@</SPAN>
 
 LUA_API void lua_seti (lua_State *L, int idx, lua_Integer n) {
   StkId t;
<SPAN CLASS="del">-  const TValue *aux;</SPAN>
<SPAN CLASS="add">+  const TValue *slot;</SPAN>
   lua_lock(L);
   api_checknelems(L, 1);
   t = index2addr(L, idx);
<SPAN CLASS="del">-  if (luaV_fastset(L, t, n, aux, luaH_getint, L-&gt;top - 1))</SPAN>
<SPAN CLASS="add">+  if (luaV_fastset(L, t, n, slot, luaH_getint, L-&gt;top - 1))</SPAN>
     L-&gt;top--;  /* pop value */
   else {
     setivalue(L-&gt;top, n);
     api_incr_top(L);
<SPAN CLASS="del">-    luaV_finishset(L, t, L-&gt;top - 1, L-&gt;top - 2, aux);</SPAN>
<SPAN CLASS="add">+    luaV_finishset(L, t, L-&gt;top - 1, L-&gt;top - 2, slot);</SPAN>
     L-&gt;top -= 2;  /* pop value and key */
   }
   lua_unlock(L);

<SPAN CLASS="etc">@@ -1140,7 +1140,6 @@</SPAN>
   lua_lock(L);
   api_checknelems(L, n);
   if (n &gt;= 2) {
<SPAN CLASS="del">-    luaC_checkGC(L);</SPAN>
     luaV_concat(L, n);
   }
   else if (n == 0) {  /* push empty string */

<SPAN CLASS="etc">@@ -1148,6 +1147,7 @@</SPAN>
     api_incr_top(L);
   }
   /* else n == 1; nothing to do */
<SPAN CLASS="add">+  luaC_checkGC(L);</SPAN>
   lua_unlock(L);
 }
 

<SPAN CLASS="etc">@@ -1183,10 +1183,10 @@</SPAN>
 LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
   Udata *u;
   lua_lock(L);
<SPAN CLASS="del">-  luaC_checkGC(L);</SPAN>
   u = luaS_newudata(L, size);
   setuvalue(L, L-&gt;top, u);
   api_incr_top(L);
<SPAN CLASS="add">+  luaC_checkGC(L);</SPAN>
   lua_unlock(L);
   return getudatamem(u);
 }

<SPAN CLASS="diff">src/lauxlib.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lauxlib.c,v 1.284 2015/11/19 19:16:22 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lauxlib.c,v 1.286 2016/01/08 15:33:09 roberto Exp $</SPAN>
 ** Auxiliary functions for building Lua libraries
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -17,7 +17,8 @@</SPAN>
 #include &lt;string.h&gt;
 
 
<SPAN CLASS="del">-/* This file uses only the official API of Lua.</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** This file uses only the official API of Lua.</SPAN>
 ** Any function declared here could be written as an application function.
 */
 

<SPAN CLASS="etc">@@ -198,6 +199,10 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** The use of 'lua_pushfstring' ensures this function does not</SPAN>
<SPAN CLASS="add">+** need reserved stack space when called.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 LUALIB_API void luaL_where (lua_State *L, int level) {
   lua_Debug ar;
   if (lua_getstack(L, level, &amp;ar)) {  /* check function at level */

<SPAN CLASS="etc">@@ -207,10 +212,15 @@</SPAN>
       return;
     }
   }
<SPAN CLASS="del">-  lua_pushliteral(L, "");  /* else, no information available... */</SPAN>
<SPAN CLASS="add">+  lua_pushfstring(L, "");  /* else, no information available... */</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Again, the use of 'lua_pushvfstring' ensures this function does</SPAN>
<SPAN CLASS="add">+** not need reserved stack space when called. (At worst, it generates</SPAN>
<SPAN CLASS="add">+** an error with "stack overflow" instead of the given message.)</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
   va_list argp;
   va_start(argp, fmt);

<SPAN CLASS="etc">@@ -349,10 +359,15 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Ensures the stack has at least 'space' extra slots, raising an error</SPAN>
<SPAN CLASS="add">+** if it cannot fulfill the request. (The error handling needs a few</SPAN>
<SPAN CLASS="add">+** extra slots to format the error message. In case of an error without</SPAN>
<SPAN CLASS="add">+** this extra space, Lua will generate the same 'stack overflow' error,</SPAN>
<SPAN CLASS="add">+** but without 'msg'.)</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *msg) {
<SPAN CLASS="del">-  /* keep some extra space to run error routines, if needed */</SPAN>
<SPAN CLASS="del">-  const int extra = LUA_MINSTACK;</SPAN>
<SPAN CLASS="del">-  if (!lua_checkstack(L, space + extra)) {</SPAN>
<SPAN CLASS="add">+  if (!lua_checkstack(L, space)) {</SPAN>
     if (msg)
       luaL_error(L, "stack overflow (%s)", msg);
     else

<SPAN CLASS="etc">@@ -678,7 +693,7 @@</SPAN>
   if (c == '#') {  /* first line is a comment (Unix exec. file)? */
     do {  /* skip first line */
       c = getc(lf-&gt;f);
<SPAN CLASS="del">-    } while (c != EOF &amp;&amp; c != '\n') ;</SPAN>
<SPAN CLASS="add">+    } while (c != EOF &amp;&amp; c != '\n');</SPAN>
     *cp = getc(lf-&gt;f);  /* skip end-of-line, if present */
     return 1;  /* there was a comment */
   }

<SPAN CLASS="diff">src/lbaselib.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lbaselib.c,v 1.312 2015/10/29 15:21:04 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lbaselib.c,v 1.313 2016/04/11 19:18:40 roberto Exp $</SPAN>
 ** Basic library
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -102,8 +102,8 @@</SPAN>
 static int luaB_error (lua_State *L) {
   int level = (int)luaL_optinteger(L, 2, 1);
   lua_settop(L, 1);
<SPAN CLASS="del">-  if (lua_isstring(L, 1) &amp;&amp; level &gt; 0) {  /* add extra information? */</SPAN>
<SPAN CLASS="del">-    luaL_where(L, level);</SPAN>
<SPAN CLASS="add">+  if (lua_type(L, 1) == LUA_TSTRING &amp;&amp; level &gt; 0) {</SPAN>
<SPAN CLASS="add">+    luaL_where(L, level);   /* add extra information */</SPAN>
     lua_pushvalue(L, 1);
     lua_concat(L, 2);
   }

<SPAN CLASS="etc">@@ -251,9 +251,8 @@</SPAN>
 
 
 /*
<SPAN CLASS="del">-** This function will use either 'ipairsaux' or 'ipairsaux_raw' to</SPAN>
<SPAN CLASS="del">-** traverse a table, depending on whether the table has metamethods</SPAN>
<SPAN CLASS="del">-** that can affect the traversal.</SPAN>
<SPAN CLASS="add">+** 'ipairs' function. Returns 'ipairsaux', given "table", 0.</SPAN>
<SPAN CLASS="add">+** (The given "table" may not be a table.)</SPAN>
 */
 static int luaB_ipairs (lua_State *L) {
 #if defined(LUA_COMPAT_IPAIRS)

<SPAN CLASS="diff">src/lcode.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lcode.c,v 2.103 2015/11/19 19:16:22 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lcode.c,v 2.109 2016/05/13 19:09:21 roberto Exp $</SPAN>
 ** Code generator for Lua
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -36,6 +36,10 @@</SPAN>
 #define hasjumps(e)	((e)-&gt;t != (e)-&gt;f)
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** If expression is a numeric constant, fills 'v' with its value</SPAN>
<SPAN CLASS="add">+** and returns 1. Otherwise, returns 0.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static int tonumeral(expdesc *e, TValue *v) {
   if (hasjumps(e))
     return 0;  /* not a numeral */

<SPAN CLASS="etc">@@ -51,13 +55,19 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Create a OP_LOADNIL instruction, but try to optimize: if the previous</SPAN>
<SPAN CLASS="add">+** instruction is also OP_LOADNIL and ranges are compatible, adjust</SPAN>
<SPAN CLASS="add">+** range of previous instruction instead of emitting a new one. (For</SPAN>
<SPAN CLASS="add">+** instance, 'local a; local b' will generate a single opcode.)</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_nil (FuncState *fs, int from, int n) {
   Instruction *previous;
   int l = from + n - 1;  /* last register to set nil */
   if (fs-&gt;pc &gt; fs-&gt;lasttarget) {  /* no jumps to current position? */
     previous = &amp;fs-&gt;f-&gt;code[fs-&gt;pc-1];
<SPAN CLASS="del">-    if (GET_OPCODE(*previous) == OP_LOADNIL) {</SPAN>
<SPAN CLASS="del">-      int pfrom = GETARG_A(*previous);</SPAN>
<SPAN CLASS="add">+    if (GET_OPCODE(*previous) == OP_LOADNIL) {  /* previous is LOADNIL? */</SPAN>
<SPAN CLASS="add">+      int pfrom = GETARG_A(*previous);  /* get previous range */</SPAN>
       int pl = pfrom + GETARG_B(*previous);
       if ((pfrom &lt;= from &amp;&amp; from &lt;= pl + 1) ||
           (from &lt;= pfrom &amp;&amp; pfrom &lt;= l + 1)) {  /* can connect both? */

<SPAN CLASS="etc">@@ -73,37 +83,84 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Gets the destination address of a jump instruction. Used to traverse</SPAN>
<SPAN CLASS="add">+** a list of jumps.</SPAN>
<SPAN CLASS="add">+*/ </SPAN>
<SPAN CLASS="add">+static int getjump (FuncState *fs, int pc) {</SPAN>
<SPAN CLASS="add">+  int offset = GETARG_sBx(fs-&gt;f-&gt;code[pc]);</SPAN>
<SPAN CLASS="add">+  if (offset == NO_JUMP)  /* point to itself represents end of list */</SPAN>
<SPAN CLASS="add">+    return NO_JUMP;  /* end of list */</SPAN>
<SPAN CLASS="add">+  else</SPAN>
<SPAN CLASS="add">+    return (pc+1)+offset;  /* turn offset into absolute position */</SPAN>
<SPAN CLASS="add">+}</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Fix jump instruction at position 'pc' to jump to 'dest'.</SPAN>
<SPAN CLASS="add">+** (Jump addresses are relative in Lua)</SPAN>
<SPAN CLASS="add">+*/</SPAN>
<SPAN CLASS="add">+static void fixjump (FuncState *fs, int pc, int dest) {</SPAN>
<SPAN CLASS="add">+  Instruction *jmp = &amp;fs-&gt;f-&gt;code[pc];</SPAN>
<SPAN CLASS="add">+  int offset = dest - (pc + 1);</SPAN>
<SPAN CLASS="add">+  lua_assert(dest != NO_JUMP);</SPAN>
<SPAN CLASS="add">+  if (abs(offset) &gt; MAXARG_sBx)</SPAN>
<SPAN CLASS="add">+    luaX_syntaxerror(fs-&gt;ls, "control structure too long");</SPAN>
<SPAN CLASS="add">+  SETARG_sBx(*jmp, offset);</SPAN>
<SPAN CLASS="add">+}</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Concatenate jump-list 'l2' into jump-list 'l1'</SPAN>
<SPAN CLASS="add">+*/</SPAN>
<SPAN CLASS="add">+void luaK_concat (FuncState *fs, int *l1, int l2) {</SPAN>
<SPAN CLASS="add">+  if (l2 == NO_JUMP) return;  /* nothing to concatenate? */</SPAN>
<SPAN CLASS="add">+  else if (*l1 == NO_JUMP)  /* no original list? */</SPAN>
<SPAN CLASS="add">+    *l1 = l2;  /* 'l1' points to 'l2' */</SPAN>
<SPAN CLASS="add">+  else {</SPAN>
<SPAN CLASS="add">+    int list = *l1;</SPAN>
<SPAN CLASS="add">+    int next;</SPAN>
<SPAN CLASS="add">+    while ((next = getjump(fs, list)) != NO_JUMP)  /* find last element */</SPAN>
<SPAN CLASS="add">+      list = next;</SPAN>
<SPAN CLASS="add">+    fixjump(fs, list, l2);  /* last element links to 'l2' */</SPAN>
<SPAN CLASS="add">+  }</SPAN>
<SPAN CLASS="add">+}</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Create a jump instruction and return its position, so its destination</SPAN>
<SPAN CLASS="add">+** can be fixed later (with 'fixjump'). If there are jumps to</SPAN>
<SPAN CLASS="add">+** this position (kept in 'jpc'), link them all together so that</SPAN>
<SPAN CLASS="add">+** 'patchlistaux' will fix all them directly to the final destination.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 int luaK_jump (FuncState *fs) {
   int jpc = fs-&gt;jpc;  /* save list of jumps to here */
   int j;
<SPAN CLASS="del">-  fs-&gt;jpc = NO_JUMP;</SPAN>
<SPAN CLASS="add">+  fs-&gt;jpc = NO_JUMP;  /* no more jumps to here */</SPAN>
   j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
   luaK_concat(fs, &amp;j, jpc);  /* keep them on hold */
   return j;
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Code a 'return' instruction</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_ret (FuncState *fs, int first, int nret) {
   luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Code a "conditional jump", that is, a test or comparison opcode</SPAN>
<SPAN CLASS="add">+** followed by a jump. Return jump position.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static int condjump (FuncState *fs, OpCode op, int A, int B, int C) {
   luaK_codeABC(fs, op, A, B, C);
   return luaK_jump(fs);
 }
 
 
<SPAN CLASS="del">-static void fixjump (FuncState *fs, int pc, int dest) {</SPAN>
<SPAN CLASS="del">-  Instruction *jmp = &amp;fs-&gt;f-&gt;code[pc];</SPAN>
<SPAN CLASS="del">-  int offset = dest-(pc+1);</SPAN>
<SPAN CLASS="del">-  lua_assert(dest != NO_JUMP);</SPAN>
<SPAN CLASS="del">-  if (abs(offset) &gt; MAXARG_sBx)</SPAN>
<SPAN CLASS="del">-    luaX_syntaxerror(fs-&gt;ls, "control structure too long");</SPAN>
<SPAN CLASS="del">-  SETARG_sBx(*jmp, offset);</SPAN>
<SPAN CLASS="del">-}</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-</SPAN>
 /*
 ** returns current 'pc' and marks it as a jump target (to avoid wrong
 ** optimizations with consecutive instructions not in the same basic block).

<SPAN CLASS="etc">@@ -114,15 +171,11 @@</SPAN>
 }
 
 
<SPAN CLASS="del">-static int getjump (FuncState *fs, int pc) {</SPAN>
<SPAN CLASS="del">-  int offset = GETARG_sBx(fs-&gt;f-&gt;code[pc]);</SPAN>
<SPAN CLASS="del">-  if (offset == NO_JUMP)  /* point to itself represents end of list */</SPAN>
<SPAN CLASS="del">-    return NO_JUMP;  /* end of list */</SPAN>
<SPAN CLASS="del">-  else</SPAN>
<SPAN CLASS="del">-    return (pc+1)+offset;  /* turn offset into absolute position */</SPAN>
<SPAN CLASS="del">-}</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Returns the position of the instruction "controlling" a given</SPAN>
<SPAN CLASS="add">+** jump (that is, its condition), or the jump itself if it is</SPAN>
<SPAN CLASS="add">+** unconditional.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static Instruction *getjumpcontrol (FuncState *fs, int pc) {
   Instruction *pi = &amp;fs-&gt;f-&gt;code[pc];
   if (pc &gt;= 1 &amp;&amp; testTMode(GET_OPCODE(*(pi-1))))

<SPAN CLASS="etc">@@ -133,37 +186,41 @@</SPAN>
 
 
 /*
<SPAN CLASS="del">-** check whether list has any jump that do not produce a value</SPAN>
<SPAN CLASS="del">-** (or produce an inverted value)</SPAN>
<SPAN CLASS="add">+** Patch destination register for a TESTSET instruction.</SPAN>
<SPAN CLASS="add">+** If instruction in position 'node' is not a TESTSET, return 0 ("fails").</SPAN>
<SPAN CLASS="add">+** Otherwise, if 'reg' is not 'NO_REG', set it as the destination</SPAN>
<SPAN CLASS="add">+** register. Otherwise, change instruction to a simple 'TEST' (produces</SPAN>
<SPAN CLASS="add">+** no register value)</SPAN>
 */
<SPAN CLASS="del">-static int need_value (FuncState *fs, int list) {</SPAN>
<SPAN CLASS="del">-  for (; list != NO_JUMP; list = getjump(fs, list)) {</SPAN>
<SPAN CLASS="del">-    Instruction i = *getjumpcontrol(fs, list);</SPAN>
<SPAN CLASS="del">-    if (GET_OPCODE(i) != OP_TESTSET) return 1;</SPAN>
<SPAN CLASS="del">-  }</SPAN>
<SPAN CLASS="del">-  return 0;  /* not found */</SPAN>
<SPAN CLASS="del">-}</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-</SPAN>
 static int patchtestreg (FuncState *fs, int node, int reg) {
   Instruction *i = getjumpcontrol(fs, node);
   if (GET_OPCODE(*i) != OP_TESTSET)
     return 0;  /* cannot patch other instructions */
   if (reg != NO_REG &amp;&amp; reg != GETARG_B(*i))
     SETARG_A(*i, reg);
<SPAN CLASS="del">-  else  /* no register to put value or register already has the value */</SPAN>
<SPAN CLASS="add">+  else {</SPAN>
<SPAN CLASS="add">+     /* no register to put value or register already has the value;</SPAN>
<SPAN CLASS="add">+        change instruction to simple test */</SPAN>
     *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="add">+  }</SPAN>
   return 1;
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Traverse a list of tests ensuring no one produces a value</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static void removevalues (FuncState *fs, int list) {
   for (; list != NO_JUMP; list = getjump(fs, list))
       patchtestreg(fs, list, NO_REG);
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Traverse a list of tests, patching their destination address and</SPAN>
<SPAN CLASS="add">+** registers: tests producing values jump to 'vtarget' (and put their</SPAN>
<SPAN CLASS="add">+** values in 'reg'), other tests jump to 'dtarget'.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
                           int dtarget) {
   while (list != NO_JUMP) {

<SPAN CLASS="etc">@@ -177,15 +234,35 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Ensure all pending jumps to current position are fixed (jumping</SPAN>
<SPAN CLASS="add">+** to current position with no values) and reset list of pending</SPAN>
<SPAN CLASS="add">+** jumps</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static void dischargejpc (FuncState *fs) {
   patchlistaux(fs, fs-&gt;jpc, fs-&gt;pc, NO_REG, fs-&gt;pc);
   fs-&gt;jpc = NO_JUMP;
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Add elements in 'list' to list of pending jumps to "here"</SPAN>
<SPAN CLASS="add">+** (current position)</SPAN>
<SPAN CLASS="add">+*/</SPAN>
<SPAN CLASS="add">+void luaK_patchtohere (FuncState *fs, int list) {</SPAN>
<SPAN CLASS="add">+  luaK_getlabel(fs);  /* mark "here" as a jump target */</SPAN>
<SPAN CLASS="add">+  luaK_concat(fs, &amp;fs-&gt;jpc, list);</SPAN>
<SPAN CLASS="add">+}</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Path all jumps in 'list' to jump to 'target'.</SPAN>
<SPAN CLASS="add">+** (The assert means that we cannot fix a jump to a forward address</SPAN>
<SPAN CLASS="add">+** because we only know addresses once code is generated.)</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_patchlist (FuncState *fs, int list, int target) {
<SPAN CLASS="del">-  if (target == fs-&gt;pc)</SPAN>
<SPAN CLASS="del">-    luaK_patchtohere(fs, list);</SPAN>
<SPAN CLASS="add">+  if (target == fs-&gt;pc)  /* 'target' is current position? */</SPAN>
<SPAN CLASS="add">+    luaK_patchtohere(fs, list);  /* add list to pending jumps */</SPAN>
   else {
     lua_assert(target &lt; fs-&gt;pc);
     patchlistaux(fs, list, target, NO_REG, target);

<SPAN CLASS="etc">@@ -193,39 +270,26 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Path all jumps in 'list' to close upvalues up to given 'level'</SPAN>
<SPAN CLASS="add">+** (The assertion checks that jumps either were closing nothing</SPAN>
<SPAN CLASS="add">+** or were closing higher levels, from inner blocks.)</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_patchclose (FuncState *fs, int list, int level) {
   level++;  /* argument is +1 to reserve 0 as non-op */
<SPAN CLASS="del">-  while (list != NO_JUMP) {</SPAN>
<SPAN CLASS="del">-    int next = getjump(fs, list);</SPAN>
<SPAN CLASS="add">+  for (; list != NO_JUMP; list = getjump(fs, list)) {</SPAN>
     lua_assert(GET_OPCODE(fs-&gt;f-&gt;code[list]) == OP_JMP &amp;&amp;
                 (GETARG_A(fs-&gt;f-&gt;code[list]) == 0 ||
                  GETARG_A(fs-&gt;f-&gt;code[list]) &gt;= level));
     SETARG_A(fs-&gt;f-&gt;code[list], level);
<SPAN CLASS="del">-    list = next;</SPAN>
<SPAN CLASS="del">-  }</SPAN>
<SPAN CLASS="del">-}</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-void luaK_patchtohere (FuncState *fs, int list) {</SPAN>
<SPAN CLASS="del">-  luaK_getlabel(fs);</SPAN>
<SPAN CLASS="del">-  luaK_concat(fs, &amp;fs-&gt;jpc, list);</SPAN>
<SPAN CLASS="del">-}</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-void luaK_concat (FuncState *fs, int *l1, int l2) {</SPAN>
<SPAN CLASS="del">-  if (l2 == NO_JUMP) return;</SPAN>
<SPAN CLASS="del">-  else if (*l1 == NO_JUMP)</SPAN>
<SPAN CLASS="del">-    *l1 = l2;</SPAN>
<SPAN CLASS="del">-  else {</SPAN>
<SPAN CLASS="del">-    int list = *l1;</SPAN>
<SPAN CLASS="del">-    int next;</SPAN>
<SPAN CLASS="del">-    while ((next = getjump(fs, list)) != NO_JUMP)  /* find last element */</SPAN>
<SPAN CLASS="del">-      list = next;</SPAN>
<SPAN CLASS="del">-    fixjump(fs, list, l2);</SPAN>
   }
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Emit instruction 'i', checking for array sizes and saving also its</SPAN>
<SPAN CLASS="add">+** line information. Return 'i' position.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static int luaK_code (FuncState *fs, Instruction i) {
   Proto *f = fs-&gt;f;
   dischargejpc(fs);  /* 'pc' will change */

<SPAN CLASS="etc">@@ -241,6 +305,10 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Format and emit an 'iABC' instruction. (Assertions check consistency</SPAN>
<SPAN CLASS="add">+** of parameters versus opcode.)</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
   lua_assert(getOpMode(o) == iABC);
   lua_assert(getBMode(o) != OpArgN || b == 0);

<SPAN CLASS="etc">@@ -250,6 +318,9 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Format and emit an 'iABx' instruction.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
   lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);
   lua_assert(getCMode(o) == OpArgN);

<SPAN CLASS="etc">@@ -258,12 +329,20 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Emit an "extra argument" instruction (format 'iAx')</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static int codeextraarg (FuncState *fs, int a) {
   lua_assert(a &lt;= MAXARG_Ax);
   return luaK_code(fs, CREATE_Ax(OP_EXTRAARG, a));
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Emit a "load constant" instruction, using either 'OP_LOADK'</SPAN>
<SPAN CLASS="add">+** (if constant index 'k' fits in 18 bits) or an 'OP_LOADKX'</SPAN>
<SPAN CLASS="add">+** instruction with "extra argument".</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 int luaK_codek (FuncState *fs, int reg, int k) {
   if (k &lt;= MAXARG_Bx)
     return luaK_codeABx(fs, OP_LOADK, reg, k);

<SPAN CLASS="etc">@@ -275,6 +354,10 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Check register-stack level, keeping track of its maximum size</SPAN>
<SPAN CLASS="add">+** in field 'maxstacksize'</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_checkstack (FuncState *fs, int n) {
   int newstack = fs-&gt;freereg + n;
   if (newstack &gt; fs-&gt;f-&gt;maxstacksize) {

<SPAN CLASS="etc">@@ -286,12 +369,20 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Reserve 'n' registers in register stack</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_reserveregs (FuncState *fs, int n) {
   luaK_checkstack(fs, n);
   fs-&gt;freereg += n;
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Free register 'reg', if it is neither a constant index nor</SPAN>
<SPAN CLASS="add">+** a local variable.</SPAN>
<SPAN CLASS="add">+)</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static void freereg (FuncState *fs, int reg) {
   if (!ISK(reg) &amp;&amp; reg &gt;= fs-&gt;nactvar) {
     fs-&gt;freereg--;

<SPAN CLASS="etc">@@ -300,6 +391,9 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Free register used by expression 'e' (if any)</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static void freeexp (FuncState *fs, expdesc *e) {
   if (e-&gt;k == VNONRELOC)
     freereg(fs, e-&gt;u.info);

<SPAN CLASS="etc">@@ -307,8 +401,29 @@</SPAN>
 
 
 /*
<SPAN CLASS="add">+** Free registers used by expressions 'e1' and 'e2' (if any) in proper</SPAN>
<SPAN CLASS="add">+** order.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
<SPAN CLASS="add">+static void freeexps (FuncState *fs, expdesc *e1, expdesc *e2) {</SPAN>
<SPAN CLASS="add">+  int r1 = (e1-&gt;k == VNONRELOC) ? e1-&gt;u.info : -1;</SPAN>
<SPAN CLASS="add">+  int r2 = (e2-&gt;k == VNONRELOC) ? e2-&gt;u.info : -1;</SPAN>
<SPAN CLASS="add">+  if (r1 &gt; r2) {</SPAN>
<SPAN CLASS="add">+    freereg(fs, r1);</SPAN>
<SPAN CLASS="add">+    freereg(fs, r2);</SPAN>
<SPAN CLASS="add">+  }</SPAN>
<SPAN CLASS="add">+  else {</SPAN>
<SPAN CLASS="add">+    freereg(fs, r2);</SPAN>
<SPAN CLASS="add">+    freereg(fs, r1);</SPAN>
<SPAN CLASS="add">+  }</SPAN>
<SPAN CLASS="add">+}</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Add constant 'v' to prototype's list of constants (field 'k').</SPAN>
 ** Use scanner's table to cache position of constants in constant list
<SPAN CLASS="del">-** and try to reuse constants</SPAN>
<SPAN CLASS="add">+** and try to reuse constants. Because some values should not be used</SPAN>
<SPAN CLASS="add">+** as keys (nil cannot be a key, integer keys can collapse with float</SPAN>
<SPAN CLASS="add">+** keys), the caller must provide a useful 'key' for indexing the cache.</SPAN>
 */
 static int addk (FuncState *fs, TValue *key, TValue *v) {
   lua_State *L = fs-&gt;ls-&gt;L;

<SPAN CLASS="etc">@@ -337,17 +452,21 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Add a string to list of constants and return its index.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 int luaK_stringK (FuncState *fs, TString *s) {
   TValue o;
   setsvalue(fs-&gt;ls-&gt;L, &amp;o, s);
<SPAN CLASS="del">-  return addk(fs, &amp;o, &amp;o);</SPAN>
<SPAN CLASS="add">+  return addk(fs, &amp;o, &amp;o);  /* use string itself as key */</SPAN>
 }
 
 
 /*
<SPAN CLASS="del">-** Integers use userdata as keys to avoid collision with floats with same</SPAN>
<SPAN CLASS="del">-** value; conversion to 'void*' used only for hashing, no "precision"</SPAN>
<SPAN CLASS="del">-** problems</SPAN>
<SPAN CLASS="add">+** Add an integer to list of constants and return its index.</SPAN>
<SPAN CLASS="add">+** Integers use userdata as keys to avoid collision with floats with</SPAN>
<SPAN CLASS="add">+** same value; conversion to 'void*' is used only for hashing, so there</SPAN>
<SPAN CLASS="add">+** are no "precision" problems.</SPAN>
 */
 int luaK_intK (FuncState *fs, lua_Integer n) {
   TValue k, o;

<SPAN CLASS="etc">@@ -356,21 +475,29 @@</SPAN>
   return addk(fs, &amp;k, &amp;o);
 }
 
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Add a float to list of constants and return its index.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static int luaK_numberK (FuncState *fs, lua_Number r) {
   TValue o;
   setfltvalue(&amp;o, r);
<SPAN CLASS="del">-  return addk(fs, &amp;o, &amp;o);</SPAN>
<SPAN CLASS="add">+  return addk(fs, &amp;o, &amp;o);  /* use number itself as key */</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Add a boolean to list of constants and return its index.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static int boolK (FuncState *fs, int b) {
   TValue o;
   setbvalue(&amp;o, b);
<SPAN CLASS="del">-  return addk(fs, &amp;o, &amp;o);</SPAN>
<SPAN CLASS="add">+  return addk(fs, &amp;o, &amp;o);  /* use boolean itself as key */</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Add nil to list of constants and return its index.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static int nilK (FuncState *fs) {
   TValue k, v;
   setnilvalue(&amp;v);

<SPAN CLASS="etc">@@ -380,54 +507,79 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Fix an expression to return the number of results 'nresults'.</SPAN>
<SPAN CLASS="add">+** Either 'e' is a multi-ret expression (function call or vararg)</SPAN>
<SPAN CLASS="add">+** or 'nresults' is LUA_MULTRET (as any expression can satisfy that).</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {
   if (e-&gt;k == VCALL) {  /* expression is an open function call? */
<SPAN CLASS="del">-    SETARG_C(getcode(fs, e), nresults+1);</SPAN>
<SPAN CLASS="add">+    SETARG_C(getinstruction(fs, e), nresults + 1);</SPAN>
   }
   else if (e-&gt;k == VVARARG) {
<SPAN CLASS="del">-    SETARG_B(getcode(fs, e), nresults+1);</SPAN>
<SPAN CLASS="del">-    SETARG_A(getcode(fs, e), fs-&gt;freereg);</SPAN>
<SPAN CLASS="add">+    Instruction *pc = &amp;getinstruction(fs, e);</SPAN>
<SPAN CLASS="add">+    SETARG_B(*pc, nresults + 1);</SPAN>
<SPAN CLASS="add">+    SETARG_A(*pc, fs-&gt;freereg);</SPAN>
     luaK_reserveregs(fs, 1);
   }
<SPAN CLASS="add">+  else lua_assert(nresults == LUA_MULTRET);</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Fix an expression to return one result.</SPAN>
<SPAN CLASS="add">+** If expression is not a multi-ret expression (function call or</SPAN>
<SPAN CLASS="add">+** vararg), it already returns one result, so nothing needs to be done.</SPAN>
<SPAN CLASS="add">+** Function calls become VNONRELOC expressions (as its result comes</SPAN>
<SPAN CLASS="add">+** fixed in the base register of the call), while vararg expressions</SPAN>
<SPAN CLASS="add">+** become VRELOCABLE (as OP_VARARG puts its results where it wants).</SPAN>
<SPAN CLASS="add">+** (Calls are created returning one result, so that does not need</SPAN>
<SPAN CLASS="add">+** to be fixed.)</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_setoneret (FuncState *fs, expdesc *e) {
   if (e-&gt;k == VCALL) {  /* expression is an open function call? */
<SPAN CLASS="del">-    e-&gt;k = VNONRELOC;</SPAN>
<SPAN CLASS="del">-    e-&gt;u.info = GETARG_A(getcode(fs, e));</SPAN>
<SPAN CLASS="add">+    /* already returns 1 value */</SPAN>
<SPAN CLASS="add">+    lua_assert(GETARG_C(getinstruction(fs, e)) == 2);</SPAN>
<SPAN CLASS="add">+    e-&gt;k = VNONRELOC;  /* result has fixed position */</SPAN>
<SPAN CLASS="add">+    e-&gt;u.info = GETARG_A(getinstruction(fs, e));</SPAN>
   }
   else if (e-&gt;k == VVARARG) {
<SPAN CLASS="del">-    SETARG_B(getcode(fs, e), 2);</SPAN>
<SPAN CLASS="add">+    SETARG_B(getinstruction(fs, e), 2);</SPAN>
     e-&gt;k = VRELOCABLE;  /* can relocate its simple result */
   }
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Ensure that expression 'e' is not a variable.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_dischargevars (FuncState *fs, expdesc *e) {
   switch (e-&gt;k) {
<SPAN CLASS="del">-    case VLOCAL: {</SPAN>
<SPAN CLASS="del">-      e-&gt;k = VNONRELOC;</SPAN>
<SPAN CLASS="add">+    case VLOCAL: {  /* already in a register */</SPAN>
<SPAN CLASS="add">+      e-&gt;k = VNONRELOC;  /* becomes a non-relocatable value */</SPAN>
       break;
     }
<SPAN CLASS="del">-    case VUPVAL: {</SPAN>
<SPAN CLASS="add">+    case VUPVAL: {  /* move value to some (pending) register */</SPAN>
       e-&gt;u.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e-&gt;u.info, 0);
       e-&gt;k = VRELOCABLE;
       break;
     }
     case VINDEXED: {
<SPAN CLASS="del">-      OpCode op = OP_GETTABUP;  /* assume 't' is in an upvalue */</SPAN>
<SPAN CLASS="add">+      OpCode op;</SPAN>
       freereg(fs, e-&gt;u.ind.idx);
<SPAN CLASS="del">-      if (e-&gt;u.ind.vt == VLOCAL) {  /* 't' is in a register? */</SPAN>
<SPAN CLASS="add">+      if (e-&gt;u.ind.vt == VLOCAL) {  /* is 't' in a register? */</SPAN>
         freereg(fs, e-&gt;u.ind.t);
         op = OP_GETTABLE;
       }
<SPAN CLASS="add">+      else {</SPAN>
<SPAN CLASS="add">+        lua_assert(e-&gt;u.ind.vt == VUPVAL);</SPAN>
<SPAN CLASS="add">+        op = OP_GETTABUP;  /* 't' is in an upvalue */</SPAN>
<SPAN CLASS="add">+      }</SPAN>
       e-&gt;u.info = luaK_codeABC(fs, op, 0, e-&gt;u.ind.t, e-&gt;u.ind.idx);
       e-&gt;k = VRELOCABLE;
       break;
     }
<SPAN CLASS="del">-    case VVARARG:</SPAN>
<SPAN CLASS="del">-    case VCALL: {</SPAN>
<SPAN CLASS="add">+    case VVARARG: case VCALL: {</SPAN>
       luaK_setoneret(fs, e);
       break;
     }

<SPAN CLASS="etc">@@ -436,12 +588,10 @@</SPAN>
 }
 
 
<SPAN CLASS="del">-static int code_label (FuncState *fs, int A, int b, int jump) {</SPAN>
<SPAN CLASS="del">-  luaK_getlabel(fs);  /* those instructions may be jump targets */</SPAN>
<SPAN CLASS="del">-  return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);</SPAN>
<SPAN CLASS="del">-}</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Ensures expression value is in register 'reg' (and therefore</SPAN>
<SPAN CLASS="add">+** 'e' will become a non-relocatable expression).</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
   luaK_dischargevars(fs, e);
   switch (e-&gt;k) {

<SPAN CLASS="etc">@@ -466,8 +616,8 @@</SPAN>
       break;
     }
     case VRELOCABLE: {
<SPAN CLASS="del">-      Instruction *pc = &amp;getcode(fs, e);</SPAN>
<SPAN CLASS="del">-      SETARG_A(*pc, reg);</SPAN>
<SPAN CLASS="add">+      Instruction *pc = &amp;getinstruction(fs, e);</SPAN>
<SPAN CLASS="add">+      SETARG_A(*pc, reg);  /* instruction will put result in 'reg' */</SPAN>
       break;
     }
     case VNONRELOC: {

<SPAN CLASS="etc">@@ -476,7 +626,7 @@</SPAN>
       break;
     }
     default: {
<SPAN CLASS="del">-      lua_assert(e-&gt;k == VVOID || e-&gt;k == VJMP);</SPAN>
<SPAN CLASS="add">+      lua_assert(e-&gt;k == VJMP);</SPAN>
       return;  /* nothing to do... */
     }
   }

<SPAN CLASS="etc">@@ -485,17 +635,46 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Ensures expression value is in any register.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static void discharge2anyreg (FuncState *fs, expdesc *e) {
<SPAN CLASS="del">-  if (e-&gt;k != VNONRELOC) {</SPAN>
<SPAN CLASS="del">-    luaK_reserveregs(fs, 1);</SPAN>
<SPAN CLASS="del">-    discharge2reg(fs, e, fs-&gt;freereg-1);</SPAN>
<SPAN CLASS="add">+  if (e-&gt;k != VNONRELOC) {  /* no fixed register yet? */</SPAN>
<SPAN CLASS="add">+    luaK_reserveregs(fs, 1);  /* get a register */</SPAN>
<SPAN CLASS="add">+    discharge2reg(fs, e, fs-&gt;freereg-1);  /* put value there */</SPAN>
<SPAN CLASS="add">+  }</SPAN>
<SPAN CLASS="add">+}</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+static int code_loadbool (FuncState *fs, int A, int b, int jump) {</SPAN>
<SPAN CLASS="add">+  luaK_getlabel(fs);  /* those instructions may be jump targets */</SPAN>
<SPAN CLASS="add">+  return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);</SPAN>
<SPAN CLASS="add">+}</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** check whether list has any jump that do not produce a value</SPAN>
<SPAN CLASS="add">+** or produce an inverted value</SPAN>
<SPAN CLASS="add">+*/</SPAN>
<SPAN CLASS="add">+static int need_value (FuncState *fs, int list) {</SPAN>
<SPAN CLASS="add">+  for (; list != NO_JUMP; list = getjump(fs, list)) {</SPAN>
<SPAN CLASS="add">+    Instruction i = *getjumpcontrol(fs, list);</SPAN>
<SPAN CLASS="add">+    if (GET_OPCODE(i) != OP_TESTSET) return 1;</SPAN>
   }
<SPAN CLASS="add">+  return 0;  /* not found */</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Ensures final expression result (including results from its jump</SPAN>
<SPAN CLASS="add">+** lists) is in register 'reg'.</SPAN>
<SPAN CLASS="add">+** If expression has jumps, need to patch these jumps either to</SPAN>
<SPAN CLASS="add">+** its final position or to "load" instructions (for those tests</SPAN>
<SPAN CLASS="add">+** that do not produce values).</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static void exp2reg (FuncState *fs, expdesc *e, int reg) {
   discharge2reg(fs, e, reg);
<SPAN CLASS="del">-  if (e-&gt;k == VJMP)</SPAN>
<SPAN CLASS="add">+  if (e-&gt;k == VJMP)  /* expression itself is a test? */</SPAN>
     luaK_concat(fs, &amp;e-&gt;t, e-&gt;u.info);  /* put this jump in 't' list */
   if (hasjumps(e)) {
     int final;  /* position after whole expression */

<SPAN CLASS="etc">@@ -503,8 +682,8 @@</SPAN>
     int p_t = NO_JUMP;  /* position of an eventual LOAD true */
     if (need_value(fs, e-&gt;t) || need_value(fs, e-&gt;f)) {
       int fj = (e-&gt;k == VJMP) ? NO_JUMP : luaK_jump(fs);
<SPAN CLASS="del">-      p_f = code_label(fs, reg, 0, 1);</SPAN>
<SPAN CLASS="del">-      p_t = code_label(fs, reg, 1, 0);</SPAN>
<SPAN CLASS="add">+      p_f = code_loadbool(fs, reg, 0, 1);</SPAN>
<SPAN CLASS="add">+      p_t = code_loadbool(fs, reg, 1, 0);</SPAN>
       luaK_patchtohere(fs, fj);
     }
     final = luaK_getlabel(fs);

<SPAN CLASS="etc">@@ -517,6 +696,10 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Ensures final expression result (including results from its jump</SPAN>
<SPAN CLASS="add">+** lists) is in next available register.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
   luaK_dischargevars(fs, e);
   freeexp(fs, e);

<SPAN CLASS="etc">@@ -525,26 +708,39 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Ensures final expression result (including results from its jump</SPAN>
<SPAN CLASS="add">+** lists) is in some (any) register and return that register.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
   luaK_dischargevars(fs, e);
<SPAN CLASS="del">-  if (e-&gt;k == VNONRELOC) {</SPAN>
<SPAN CLASS="del">-    if (!hasjumps(e)) return e-&gt;u.info;  /* exp is already in a register */</SPAN>
<SPAN CLASS="add">+  if (e-&gt;k == VNONRELOC) {  /* expression already has a register? */</SPAN>
<SPAN CLASS="add">+    if (!hasjumps(e))  /* no jumps? */</SPAN>
<SPAN CLASS="add">+      return e-&gt;u.info;  /* result is already in a register */</SPAN>
     if (e-&gt;u.info &gt;= fs-&gt;nactvar) {  /* reg. is not a local? */
<SPAN CLASS="del">-      exp2reg(fs, e, e-&gt;u.info);  /* put value on it */</SPAN>
<SPAN CLASS="add">+      exp2reg(fs, e, e-&gt;u.info);  /* put final result in it */</SPAN>
       return e-&gt;u.info;
     }
   }
<SPAN CLASS="del">-  luaK_exp2nextreg(fs, e);  /* default */</SPAN>
<SPAN CLASS="add">+  luaK_exp2nextreg(fs, e);  /* otherwise, use next available register */</SPAN>
   return e-&gt;u.info;
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Ensures final expression result is either in a register or in an</SPAN>
<SPAN CLASS="add">+** upvalue.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_exp2anyregup (FuncState *fs, expdesc *e) {
   if (e-&gt;k != VUPVAL || hasjumps(e))
     luaK_exp2anyreg(fs, e);
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Ensures final expression result is either in a register or it is</SPAN>
<SPAN CLASS="add">+** a constant.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_exp2val (FuncState *fs, expdesc *e) {
   if (hasjumps(e))
     luaK_exp2anyreg(fs, e);

<SPAN CLASS="etc">@@ -553,35 +749,26 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Ensures final expression result is in a valid R/K index</SPAN>
<SPAN CLASS="add">+** (that is, it is either in a register or in 'k' with an index</SPAN>
<SPAN CLASS="add">+** in the range of R/K indices).</SPAN>
<SPAN CLASS="add">+** Returns R/K index.</SPAN>
<SPAN CLASS="add">+*/  </SPAN>
 int luaK_exp2RK (FuncState *fs, expdesc *e) {
   luaK_exp2val(fs, e);
<SPAN CLASS="del">-  switch (e-&gt;k) {</SPAN>
<SPAN CLASS="del">-    case VTRUE:</SPAN>
<SPAN CLASS="del">-    case VFALSE:</SPAN>
<SPAN CLASS="del">-    case VNIL: {</SPAN>
<SPAN CLASS="del">-      if (fs-&gt;nk &lt;= MAXINDEXRK) {  /* constant fits in RK operand? */</SPAN>
<SPAN CLASS="del">-        e-&gt;u.info = (e-&gt;k == VNIL) ? nilK(fs) : boolK(fs, (e-&gt;k == VTRUE));</SPAN>
<SPAN CLASS="del">-        e-&gt;k = VK;</SPAN>
<SPAN CLASS="del">-        return RKASK(e-&gt;u.info);</SPAN>
<SPAN CLASS="del">-      }</SPAN>
<SPAN CLASS="del">-      else break;</SPAN>
<SPAN CLASS="del">-    }</SPAN>
<SPAN CLASS="del">-    case VKINT: {</SPAN>
<SPAN CLASS="del">-      e-&gt;u.info = luaK_intK(fs, e-&gt;u.ival);</SPAN>
<SPAN CLASS="del">-      e-&gt;k = VK;</SPAN>
<SPAN CLASS="del">-      goto vk;</SPAN>
<SPAN CLASS="del">-    }</SPAN>
<SPAN CLASS="del">-    case VKFLT: {</SPAN>
<SPAN CLASS="del">-      e-&gt;u.info = luaK_numberK(fs, e-&gt;u.nval);</SPAN>
<SPAN CLASS="del">-      e-&gt;k = VK;</SPAN>
<SPAN CLASS="del">-    }</SPAN>
<SPAN CLASS="del">-    /* FALLTHROUGH */</SPAN>
<SPAN CLASS="del">-    case VK: {</SPAN>
<SPAN CLASS="add">+  switch (e-&gt;k) {  /* move constants to 'k' */</SPAN>
<SPAN CLASS="add">+    case VTRUE: e-&gt;u.info = boolK(fs, 1); goto vk;</SPAN>
<SPAN CLASS="add">+    case VFALSE: e-&gt;u.info = boolK(fs, 0); goto vk;</SPAN>
<SPAN CLASS="add">+    case VNIL: e-&gt;u.info = nilK(fs); goto vk;</SPAN>
<SPAN CLASS="add">+    case VKINT: e-&gt;u.info = luaK_intK(fs, e-&gt;u.ival); goto vk;</SPAN>
<SPAN CLASS="add">+    case VKFLT: e-&gt;u.info = luaK_numberK(fs, e-&gt;u.nval); goto vk;</SPAN>
<SPAN CLASS="add">+    case VK:</SPAN>
      vk:
<SPAN CLASS="add">+      e-&gt;k = VK;</SPAN>
       if (e-&gt;u.info &lt;= MAXINDEXRK)  /* constant fits in 'argC'? */
         return RKASK(e-&gt;u.info);
       else break;
<SPAN CLASS="del">-    }</SPAN>
     default: break;
   }
   /* not a constant in the right range: put it in a register */

<SPAN CLASS="etc">@@ -589,11 +776,14 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Generate code to store result of expression 'ex' into variable 'var'.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
   switch (var-&gt;k) {
     case VLOCAL: {
       freeexp(fs, ex);
<SPAN CLASS="del">-      exp2reg(fs, ex, var-&gt;u.info);</SPAN>
<SPAN CLASS="add">+      exp2reg(fs, ex, var-&gt;u.info);  /* compute 'ex' into proper place */</SPAN>
       return;
     }
     case VUPVAL: {

<SPAN CLASS="etc">@@ -607,29 +797,32 @@</SPAN>
       luaK_codeABC(fs, op, var-&gt;u.ind.t, var-&gt;u.ind.idx, e);
       break;
     }
<SPAN CLASS="del">-    default: {</SPAN>
<SPAN CLASS="del">-      lua_assert(0);  /* invalid var kind to store */</SPAN>
<SPAN CLASS="del">-      break;</SPAN>
<SPAN CLASS="del">-    }</SPAN>
<SPAN CLASS="add">+    default: lua_assert(0);  /* invalid var kind to store */</SPAN>
   }
   freeexp(fs, ex);
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Emit SELF instruction (convert expression 'e' into 'e:key(e,').</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
   int ereg;
   luaK_exp2anyreg(fs, e);
   ereg = e-&gt;u.info;  /* register where 'e' was placed */
   freeexp(fs, e);
   e-&gt;u.info = fs-&gt;freereg;  /* base register for op_self */
<SPAN CLASS="del">-  e-&gt;k = VNONRELOC;</SPAN>
<SPAN CLASS="add">+  e-&gt;k = VNONRELOC;  /* self expression has a fixed register */</SPAN>
   luaK_reserveregs(fs, 2);  /* function and 'self' produced by op_self */
   luaK_codeABC(fs, OP_SELF, e-&gt;u.info, ereg, luaK_exp2RK(fs, key));
   freeexp(fs, key);
 }
 
 
<SPAN CLASS="del">-static void invertjump (FuncState *fs, expdesc *e) {</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Negate condition 'e' (where 'e' is a comparison).</SPAN>
<SPAN CLASS="add">+*/</SPAN>
<SPAN CLASS="add">+static void negatecondition (FuncState *fs, expdesc *e) {</SPAN>
   Instruction *pc = getjumpcontrol(fs, e-&gt;u.info);
   lua_assert(testTMode(GET_OPCODE(*pc)) &amp;&amp; GET_OPCODE(*pc) != OP_TESTSET &amp;&amp;
                                            GET_OPCODE(*pc) != OP_TEST);

<SPAN CLASS="etc">@@ -637,9 +830,15 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Emit instruction to jump if 'e' is 'cond' (that is, if 'cond'</SPAN>
<SPAN CLASS="add">+** is true, code will jump if 'e' is true.) Return jump position.</SPAN>
<SPAN CLASS="add">+** Optimize when 'e' is 'not' something, inverting the condition</SPAN>
<SPAN CLASS="add">+** and removing the 'not'.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static int jumponcond (FuncState *fs, expdesc *e, int cond) {
   if (e-&gt;k == VRELOCABLE) {
<SPAN CLASS="del">-    Instruction ie = getcode(fs, e);</SPAN>
<SPAN CLASS="add">+    Instruction ie = getinstruction(fs, e);</SPAN>
     if (GET_OPCODE(ie) == OP_NOT) {
       fs-&gt;pc--;  /* remove previous OP_NOT */
       return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);

<SPAN CLASS="etc">@@ -652,13 +851,16 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Emit code to go through if 'e' is true, jump otherwise.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_goiftrue (FuncState *fs, expdesc *e) {
<SPAN CLASS="del">-  int pc;  /* pc of last jump */</SPAN>
<SPAN CLASS="add">+  int pc;  /* pc of new jump */</SPAN>
   luaK_dischargevars(fs, e);
   switch (e-&gt;k) {
<SPAN CLASS="del">-    case VJMP: {</SPAN>
<SPAN CLASS="del">-      invertjump(fs, e);</SPAN>
<SPAN CLASS="del">-      pc = e-&gt;u.info;</SPAN>
<SPAN CLASS="add">+    case VJMP: {  /* condition? */</SPAN>
<SPAN CLASS="add">+      negatecondition(fs, e);  /* jump when it is false */</SPAN>
<SPAN CLASS="add">+      pc = e-&gt;u.info;  /* save jump position */</SPAN>
       break;
     }
     case VK: case VKFLT: case VKINT: case VTRUE: {

<SPAN CLASS="etc">@@ -666,22 +868,25 @@</SPAN>
       break;
     }
     default: {
<SPAN CLASS="del">-      pc = jumponcond(fs, e, 0);</SPAN>
<SPAN CLASS="add">+      pc = jumponcond(fs, e, 0);  /* jump when false */</SPAN>
       break;
     }
   }
<SPAN CLASS="del">-  luaK_concat(fs, &amp;e-&gt;f, pc);  /* insert last jump in 'f' list */</SPAN>
<SPAN CLASS="del">-  luaK_patchtohere(fs, e-&gt;t);</SPAN>
<SPAN CLASS="add">+  luaK_concat(fs, &amp;e-&gt;f, pc);  /* insert new jump in false list */</SPAN>
<SPAN CLASS="add">+  luaK_patchtohere(fs, e-&gt;t);  /* true list jumps to here (to go through) */</SPAN>
   e-&gt;t = NO_JUMP;
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Emit code to go through if 'e' is false, jump otherwise.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_goiffalse (FuncState *fs, expdesc *e) {
<SPAN CLASS="del">-  int pc;  /* pc of last jump */</SPAN>
<SPAN CLASS="add">+  int pc;  /* pc of new jump */</SPAN>
   luaK_dischargevars(fs, e);
   switch (e-&gt;k) {
     case VJMP: {
<SPAN CLASS="del">-      pc = e-&gt;u.info;</SPAN>
<SPAN CLASS="add">+      pc = e-&gt;u.info;  /* already jump if true */</SPAN>
       break;
     }
     case VNIL: case VFALSE: {

<SPAN CLASS="etc">@@ -689,29 +894,32 @@</SPAN>
       break;
     }
     default: {
<SPAN CLASS="del">-      pc = jumponcond(fs, e, 1);</SPAN>
<SPAN CLASS="add">+      pc = jumponcond(fs, e, 1);  /* jump if true */</SPAN>
       break;
     }
   }
<SPAN CLASS="del">-  luaK_concat(fs, &amp;e-&gt;t, pc);  /* insert last jump in 't' list */</SPAN>
<SPAN CLASS="del">-  luaK_patchtohere(fs, e-&gt;f);</SPAN>
<SPAN CLASS="add">+  luaK_concat(fs, &amp;e-&gt;t, pc);  /* insert new jump in 't' list */</SPAN>
<SPAN CLASS="add">+  luaK_patchtohere(fs, e-&gt;f);  /* false list jumps to here (to go through) */</SPAN>
   e-&gt;f = NO_JUMP;
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Code 'not e', doing constant folding.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 static void codenot (FuncState *fs, expdesc *e) {
   luaK_dischargevars(fs, e);
   switch (e-&gt;k) {
     case VNIL: case VFALSE: {
<SPAN CLASS="del">-      e-&gt;k = VTRUE;</SPAN>
<SPAN CLASS="add">+      e-&gt;k = VTRUE;  /* true == not nil == not false */</SPAN>
       break;
     }
     case VK: case VKFLT: case VKINT: case VTRUE: {
<SPAN CLASS="del">-      e-&gt;k = VFALSE;</SPAN>
<SPAN CLASS="add">+      e-&gt;k = VFALSE;  /* false == not "x" == not 0.5 == not 1 == not true */</SPAN>
       break;
     }
     case VJMP: {
<SPAN CLASS="del">-      invertjump(fs, e);</SPAN>
<SPAN CLASS="add">+      negatecondition(fs, e);</SPAN>
       break;
     }
     case VRELOCABLE:

<SPAN CLASS="etc">@@ -722,30 +930,32 @@</SPAN>
       e-&gt;k = VRELOCABLE;
       break;
     }
<SPAN CLASS="del">-    default: {</SPAN>
<SPAN CLASS="del">-      lua_assert(0);  /* cannot happen */</SPAN>
<SPAN CLASS="del">-      break;</SPAN>
<SPAN CLASS="del">-    }</SPAN>
<SPAN CLASS="add">+    default: lua_assert(0);  /* cannot happen */</SPAN>
   }
   /* interchange true and false lists */
   { int temp = e-&gt;f; e-&gt;f = e-&gt;t; e-&gt;t = temp; }
<SPAN CLASS="del">-  removevalues(fs, e-&gt;f);</SPAN>
<SPAN CLASS="add">+  removevalues(fs, e-&gt;f);  /* values are useless when negated */</SPAN>
   removevalues(fs, e-&gt;t);
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Create expression 't[k]'. 't' must have its final result already in a</SPAN>
<SPAN CLASS="add">+** register or upvalue.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
<SPAN CLASS="del">-  lua_assert(!hasjumps(t));</SPAN>
<SPAN CLASS="del">-  t-&gt;u.ind.t = t-&gt;u.info;</SPAN>
<SPAN CLASS="del">-  t-&gt;u.ind.idx = luaK_exp2RK(fs, k);</SPAN>
<SPAN CLASS="del">-  t-&gt;u.ind.vt = (t-&gt;k == VUPVAL) ? VUPVAL</SPAN>
<SPAN CLASS="del">-                                 : check_exp(vkisinreg(t-&gt;k), VLOCAL);</SPAN>
<SPAN CLASS="add">+  lua_assert(!hasjumps(t) &amp;&amp; (vkisinreg(t-&gt;k) || t-&gt;k == VUPVAL));</SPAN>
<SPAN CLASS="add">+  t-&gt;u.ind.t = t-&gt;u.info;  /* register or upvalue index */</SPAN>
<SPAN CLASS="add">+  t-&gt;u.ind.idx = luaK_exp2RK(fs, k);  /* R/K index for key */</SPAN>
<SPAN CLASS="add">+  t-&gt;u.ind.vt = (t-&gt;k == VUPVAL) ? VUPVAL : VLOCAL;</SPAN>
   t-&gt;k = VINDEXED;
 }
 
 
 /*
<SPAN CLASS="del">-** return false if folding can raise an error</SPAN>
<SPAN CLASS="add">+** Return false if folding can raise an error.</SPAN>
<SPAN CLASS="add">+** Bitwise operations need operands convertible to integers; division</SPAN>
<SPAN CLASS="add">+** operations cannot have 0 as divisor.</SPAN>
 */
 static int validop (int op, TValue *v1, TValue *v2) {
   switch (op) {

<SPAN CLASS="etc">@@ -762,7 +972,8 @@</SPAN>
 
 
 /*
<SPAN CLASS="del">-** Try to "constant-fold" an operation; return 1 iff successful</SPAN>
<SPAN CLASS="add">+** Try to "constant-fold" an operation; return 1 iff successful.</SPAN>
<SPAN CLASS="add">+** (In this case, 'e1' has the final result.)</SPAN>
 */
 static int constfolding (FuncState *fs, int op, expdesc *e1, expdesc *e2) {
   TValue v1, v2, res;

<SPAN CLASS="etc">@@ -773,7 +984,7 @@</SPAN>
     e1-&gt;k = VKINT;
     e1-&gt;u.ival = ivalue(&amp;res);
   }
<SPAN CLASS="del">-  else {  /* folds neither NaN nor 0.0 (to avoid collapsing with -0.0) */</SPAN>
<SPAN CLASS="add">+  else {  /* folds neither NaN nor 0.0 (to avoid problems with -0.0) */</SPAN>
     lua_Number n = fltvalue(&amp;res);
     if (luai_numisnan(n) || n == 0)
       return 0;

<SPAN CLASS="etc">@@ -785,81 +996,97 @@</SPAN>
 
 
 /*
<SPAN CLASS="del">-** Code for binary and unary expressions that "produce values"</SPAN>
<SPAN CLASS="del">-** (arithmetic operations, bitwise operations, concat, length). First</SPAN>
<SPAN CLASS="del">-** try to do constant folding (only for numeric [arithmetic and</SPAN>
<SPAN CLASS="del">-** bitwise] operations, which is what 'lua_arith' accepts).</SPAN>
<SPAN CLASS="add">+** Emit code for unary expressions that "produce values"</SPAN>
<SPAN CLASS="add">+** (everything but 'not').</SPAN>
<SPAN CLASS="add">+** Expression to produce final result will be encoded in 'e'.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
<SPAN CLASS="add">+static void codeunexpval (FuncState *fs, OpCode op, expdesc *e, int line) {</SPAN>
<SPAN CLASS="add">+  int r = luaK_exp2anyreg(fs, e);  /* opcodes operate only on registers */</SPAN>
<SPAN CLASS="add">+  freeexp(fs, e);</SPAN>
<SPAN CLASS="add">+  e-&gt;u.info = luaK_codeABC(fs, op, 0, r, 0);  /* generate opcode */</SPAN>
<SPAN CLASS="add">+  e-&gt;k = VRELOCABLE;  /* all those operations are relocatable */</SPAN>
<SPAN CLASS="add">+  luaK_fixline(fs, line);</SPAN>
<SPAN CLASS="add">+}</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Emit code for binary expressions that "produce values"</SPAN>
<SPAN CLASS="add">+** (everything but logical operators 'and'/'or' and comparison</SPAN>
<SPAN CLASS="add">+** operators).</SPAN>
 ** Expression to produce final result will be encoded in 'e1'.
 */
<SPAN CLASS="del">-static void codeexpval (FuncState *fs, OpCode op,</SPAN>
<SPAN CLASS="del">-                        expdesc *e1, expdesc *e2, int line) {</SPAN>
<SPAN CLASS="del">-  lua_assert(op &gt;= OP_ADD);</SPAN>
<SPAN CLASS="del">-  if (op &lt;= OP_BNOT &amp;&amp; constfolding(fs, (op - OP_ADD) + LUA_OPADD, e1, e2))</SPAN>
<SPAN CLASS="del">-    return;  /* result has been folded */</SPAN>
<SPAN CLASS="del">-  else {</SPAN>
<SPAN CLASS="del">-    int o1, o2;</SPAN>
<SPAN CLASS="del">-    /* move operands to registers (if needed) */</SPAN>
<SPAN CLASS="del">-    if (op == OP_UNM || op == OP_BNOT || op == OP_LEN) {  /* unary op? */</SPAN>
<SPAN CLASS="del">-      o2 = 0;  /* no second expression */</SPAN>
<SPAN CLASS="del">-      o1 = luaK_exp2anyreg(fs, e1);  /* cannot operate on constants */</SPAN>
<SPAN CLASS="del">-    }</SPAN>
<SPAN CLASS="del">-    else {  /* regular case (binary operators) */</SPAN>
<SPAN CLASS="del">-      o2 = luaK_exp2RK(fs, e2);  /* both operands are "RK" */</SPAN>
<SPAN CLASS="del">-      o1 = luaK_exp2RK(fs, e1);</SPAN>
<SPAN CLASS="del">-    }</SPAN>
<SPAN CLASS="del">-    if (o1 &gt; o2) {  /* free registers in proper order */</SPAN>
<SPAN CLASS="del">-      freeexp(fs, e1);</SPAN>
<SPAN CLASS="del">-      freeexp(fs, e2);</SPAN>
<SPAN CLASS="del">-    }</SPAN>
<SPAN CLASS="del">-    else {</SPAN>
<SPAN CLASS="del">-      freeexp(fs, e2);</SPAN>
<SPAN CLASS="del">-      freeexp(fs, e1);</SPAN>
<SPAN CLASS="del">-    }</SPAN>
<SPAN CLASS="del">-    e1-&gt;u.info = luaK_codeABC(fs, op, 0, o1, o2);  /* generate opcode */</SPAN>
<SPAN CLASS="del">-    e1-&gt;k = VRELOCABLE;  /* all those operations are relocatable */</SPAN>
<SPAN CLASS="del">-    luaK_fixline(fs, line);</SPAN>
<SPAN CLASS="del">-  }</SPAN>
<SPAN CLASS="add">+static void codebinexpval (FuncState *fs, OpCode op,</SPAN>
<SPAN CLASS="add">+                           expdesc *e1, expdesc *e2, int line) {</SPAN>
<SPAN CLASS="add">+  int rk1 = luaK_exp2RK(fs, e1);  /* both operands are "RK" */</SPAN>
<SPAN CLASS="add">+  int rk2 = luaK_exp2RK(fs, e2);</SPAN>
<SPAN CLASS="add">+  freeexps(fs, e1, e2);</SPAN>
<SPAN CLASS="add">+  e1-&gt;u.info = luaK_codeABC(fs, op, 0, rk1, rk2);  /* generate opcode */</SPAN>
<SPAN CLASS="add">+  e1-&gt;k = VRELOCABLE;  /* all those operations are relocatable */</SPAN>
<SPAN CLASS="add">+  luaK_fixline(fs, line);</SPAN>
 }
 
 
<SPAN CLASS="del">-static void codecomp (FuncState *fs, OpCode op, int cond, expdesc *e1,</SPAN>
<SPAN CLASS="del">-                                                          expdesc *e2) {</SPAN>
<SPAN CLASS="del">-  int o1 = luaK_exp2RK(fs, e1);</SPAN>
<SPAN CLASS="del">-  int o2 = luaK_exp2RK(fs, e2);</SPAN>
<SPAN CLASS="del">-  freeexp(fs, e2);</SPAN>
<SPAN CLASS="del">-  freeexp(fs, e1);</SPAN>
<SPAN CLASS="del">-  if (cond == 0 &amp;&amp; op != OP_EQ) {</SPAN>
<SPAN CLASS="del">-    int temp;  /* exchange args to replace by '&lt;' or '&lt;=' */</SPAN>
<SPAN CLASS="del">-    temp = o1; o1 = o2; o2 = temp;  /* o1 &lt;==&gt; o2 */</SPAN>
<SPAN CLASS="del">-    cond = 1;</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Emit code for comparisons.</SPAN>
<SPAN CLASS="add">+** 'e1' was already put in R/K form by 'luaK_infix'.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
<SPAN CLASS="add">+static void codecomp (FuncState *fs, BinOpr opr, expdesc *e1, expdesc *e2) {</SPAN>
<SPAN CLASS="add">+  int rk1 = (e1-&gt;k == VK) ? RKASK(e1-&gt;u.info)</SPAN>
<SPAN CLASS="add">+                          : check_exp(e1-&gt;k == VNONRELOC, e1-&gt;u.info);</SPAN>
<SPAN CLASS="add">+  int rk2 = luaK_exp2RK(fs, e2);</SPAN>
<SPAN CLASS="add">+  freeexps(fs, e1, e2);</SPAN>
<SPAN CLASS="add">+  switch (opr) {</SPAN>
<SPAN CLASS="add">+    case OPR_NE: {  /* '(a ~= b)' ==&gt; 'not (a == b)' */</SPAN>
<SPAN CLASS="add">+      e1-&gt;u.info = condjump(fs, OP_EQ, 0, rk1, rk2);</SPAN>
<SPAN CLASS="add">+      break;</SPAN>
<SPAN CLASS="add">+    }</SPAN>
<SPAN CLASS="add">+    case OPR_GT: case OPR_GE: {</SPAN>
<SPAN CLASS="add">+      /* '(a &gt; b)' ==&gt; '(b &lt; a)';  '(a &gt;= b)' ==&gt; '(b &lt;= a)' */</SPAN>
<SPAN CLASS="add">+      OpCode op = cast(OpCode, (opr - OPR_NE) + OP_EQ);</SPAN>
<SPAN CLASS="add">+      e1-&gt;u.info = condjump(fs, op, 1, rk2, rk1);  /* invert operands */</SPAN>
<SPAN CLASS="add">+      break;</SPAN>
<SPAN CLASS="add">+    }</SPAN>
<SPAN CLASS="add">+    default: {  /* '==', '&lt;', '&lt;=' use their own opcodes */</SPAN>
<SPAN CLASS="add">+      OpCode op = cast(OpCode, (opr - OPR_EQ) + OP_EQ);</SPAN>
<SPAN CLASS="add">+      e1-&gt;u.info = condjump(fs, op, 1, rk1, rk2);</SPAN>
<SPAN CLASS="add">+      break;</SPAN>
<SPAN CLASS="add">+    }</SPAN>
   }
<SPAN CLASS="del">-  e1-&gt;u.info = condjump(fs, op, cond, o1, o2);</SPAN>
   e1-&gt;k = VJMP;
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Aplly prefix operation 'op' to expression 'e'.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e, int line) {
<SPAN CLASS="del">-  expdesc e2;</SPAN>
<SPAN CLASS="del">-  e2.t = e2.f = NO_JUMP; e2.k = VKINT; e2.u.ival = 0;</SPAN>
<SPAN CLASS="add">+  static expdesc ef = {VKINT, {0}, NO_JUMP, NO_JUMP};  /* fake 2nd operand */</SPAN>
   switch (op) {
<SPAN CLASS="del">-    case OPR_MINUS: case OPR_BNOT: case OPR_LEN: {</SPAN>
<SPAN CLASS="del">-      codeexpval(fs, cast(OpCode, (op - OPR_MINUS) + OP_UNM), e, &amp;e2, line);</SPAN>
<SPAN CLASS="add">+    case OPR_MINUS: case OPR_BNOT:</SPAN>
<SPAN CLASS="add">+      if (constfolding(fs, op + LUA_OPUNM, e, &amp;ef))</SPAN>
<SPAN CLASS="add">+        break;</SPAN>
<SPAN CLASS="add">+      /* FALLTHROUGH */</SPAN>
<SPAN CLASS="add">+    case OPR_LEN:</SPAN>
<SPAN CLASS="add">+      codeunexpval(fs, cast(OpCode, op + OP_UNM), e, line);</SPAN>
       break;
<SPAN CLASS="del">-    }</SPAN>
     case OPR_NOT: codenot(fs, e); break;
     default: lua_assert(0);
   }
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Process 1st operand 'v' of binary operation 'op' before reading</SPAN>
<SPAN CLASS="add">+** 2nd operand.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
   switch (op) {
     case OPR_AND: {
<SPAN CLASS="del">-      luaK_goiftrue(fs, v);</SPAN>
<SPAN CLASS="add">+      luaK_goiftrue(fs, v);  /* go ahead only if 'v' is true */</SPAN>
       break;
     }
     case OPR_OR: {
<SPAN CLASS="del">-      luaK_goiffalse(fs, v);</SPAN>
<SPAN CLASS="add">+      luaK_goiffalse(fs, v);  /* go ahead only if 'v' is false */</SPAN>
       break;
     }
     case OPR_CONCAT: {

<SPAN CLASS="etc">@@ -871,7 +1098,9 @@</SPAN>
     case OPR_MOD: case OPR_POW:
     case OPR_BAND: case OPR_BOR: case OPR_BXOR:
     case OPR_SHL: case OPR_SHR: {
<SPAN CLASS="del">-      if (!tonumeral(v, NULL)) luaK_exp2RK(fs, v);</SPAN>
<SPAN CLASS="add">+      if (!tonumeral(v, NULL))</SPAN>
<SPAN CLASS="add">+        luaK_exp2RK(fs, v);</SPAN>
<SPAN CLASS="add">+      /* else keep numeral, which may be folded with 2nd operand */</SPAN>
       break;
     }
     default: {

<SPAN CLASS="etc">@@ -882,18 +1111,24 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Finalize code for binary operation, after reading 2nd operand.</SPAN>
<SPAN CLASS="add">+** For '(a .. b .. c)' (which is '(a .. (b .. c))', because</SPAN>
<SPAN CLASS="add">+** concatenation is right associative), merge second CONCAT into first</SPAN>
<SPAN CLASS="add">+** one.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_posfix (FuncState *fs, BinOpr op,
                   expdesc *e1, expdesc *e2, int line) {
   switch (op) {
     case OPR_AND: {
<SPAN CLASS="del">-      lua_assert(e1-&gt;t == NO_JUMP);  /* list must be closed */</SPAN>
<SPAN CLASS="add">+      lua_assert(e1-&gt;t == NO_JUMP);  /* list closed by 'luK_infix' */</SPAN>
       luaK_dischargevars(fs, e2);
       luaK_concat(fs, &amp;e2-&gt;f, e1-&gt;f);
       *e1 = *e2;
       break;
     }
     case OPR_OR: {
<SPAN CLASS="del">-      lua_assert(e1-&gt;f == NO_JUMP);  /* list must be closed */</SPAN>
<SPAN CLASS="add">+      lua_assert(e1-&gt;f == NO_JUMP);  /* list closed by 'luK_infix' */</SPAN>
       luaK_dischargevars(fs, e2);
       luaK_concat(fs, &amp;e2-&gt;t, e1-&gt;t);
       *e1 = *e2;

<SPAN CLASS="etc">@@ -901,15 +1136,16 @@</SPAN>
     }
     case OPR_CONCAT: {
       luaK_exp2val(fs, e2);
<SPAN CLASS="del">-      if (e2-&gt;k == VRELOCABLE &amp;&amp; GET_OPCODE(getcode(fs, e2)) == OP_CONCAT) {</SPAN>
<SPAN CLASS="del">-        lua_assert(e1-&gt;u.info == GETARG_B(getcode(fs, e2))-1);</SPAN>
<SPAN CLASS="add">+      if (e2-&gt;k == VRELOCABLE &amp;&amp;</SPAN>
<SPAN CLASS="add">+          GET_OPCODE(getinstruction(fs, e2)) == OP_CONCAT) {</SPAN>
<SPAN CLASS="add">+        lua_assert(e1-&gt;u.info == GETARG_B(getinstruction(fs, e2))-1);</SPAN>
         freeexp(fs, e1);
<SPAN CLASS="del">-        SETARG_B(getcode(fs, e2), e1-&gt;u.info);</SPAN>
<SPAN CLASS="add">+        SETARG_B(getinstruction(fs, e2), e1-&gt;u.info);</SPAN>
         e1-&gt;k = VRELOCABLE; e1-&gt;u.info = e2-&gt;u.info;
       }
       else {
         luaK_exp2nextreg(fs, e2);  /* operand must be on the 'stack' */
<SPAN CLASS="del">-        codeexpval(fs, OP_CONCAT, e1, e2, line);</SPAN>
<SPAN CLASS="add">+        codebinexpval(fs, OP_CONCAT, e1, e2, line);</SPAN>
       }
       break;
     }

<SPAN CLASS="etc">@@ -917,15 +1153,13 @@</SPAN>
     case OPR_IDIV: case OPR_MOD: case OPR_POW:
     case OPR_BAND: case OPR_BOR: case OPR_BXOR:
     case OPR_SHL: case OPR_SHR: {
<SPAN CLASS="del">-      codeexpval(fs, cast(OpCode, (op - OPR_ADD) + OP_ADD), e1, e2, line);</SPAN>
<SPAN CLASS="del">-      break;</SPAN>
<SPAN CLASS="del">-    }</SPAN>
<SPAN CLASS="del">-    case OPR_EQ: case OPR_LT: case OPR_LE: {</SPAN>
<SPAN CLASS="del">-      codecomp(fs, cast(OpCode, (op - OPR_EQ) + OP_EQ), 1, e1, e2);</SPAN>
<SPAN CLASS="add">+      if (!constfolding(fs, op + LUA_OPADD, e1, e2))</SPAN>
<SPAN CLASS="add">+        codebinexpval(fs, cast(OpCode, op + OP_ADD), e1, e2, line);</SPAN>
       break;
     }
<SPAN CLASS="add">+    case OPR_EQ: case OPR_LT: case OPR_LE:</SPAN>
     case OPR_NE: case OPR_GT: case OPR_GE: {
<SPAN CLASS="del">-      codecomp(fs, cast(OpCode, (op - OPR_NE) + OP_EQ), 0, e1, e2);</SPAN>
<SPAN CLASS="add">+      codecomp(fs, op, e1, e2);</SPAN>
       break;
     }
     default: lua_assert(0);

<SPAN CLASS="etc">@@ -933,15 +1167,25 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Change line information associated with current position.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_fixline (FuncState *fs, int line) {
   fs-&gt;f-&gt;lineinfo[fs-&gt;pc - 1] = line;
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Emit a SETLIST instruction.</SPAN>
<SPAN CLASS="add">+** 'base' is register that keeps table;</SPAN>
<SPAN CLASS="add">+** 'nelems' is #table plus those to be stored now;</SPAN>
<SPAN CLASS="add">+** 'tostore' is number of values (in registers 'base + 1',...) to add to</SPAN>
<SPAN CLASS="add">+** table (or LUA_MULTRET to add up to stack top).</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
   int c =  (nelems - 1)/LFIELDS_PER_FLUSH + 1;
   int b = (tostore == LUA_MULTRET) ? 0 : tostore;
<SPAN CLASS="del">-  lua_assert(tostore != 0);</SPAN>
<SPAN CLASS="add">+  lua_assert(tostore != 0 &amp;&amp; tostore &lt;= LFIELDS_PER_FLUSH);</SPAN>
   if (c &lt;= MAXARG_C)
     luaK_codeABC(fs, OP_SETLIST, base, b, c);
   else if (c &lt;= MAXARG_Ax) {

<SPAN CLASS="diff">src/lcode.h</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lcode.h,v 1.63 2013/12/30 20:47:58 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lcode.h,v 1.64 2016/01/05 16:22:37 roberto Exp $</SPAN>
 ** Code generator for Lua
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -40,7 +40,8 @@</SPAN>
 typedef enum UnOpr { OPR_MINUS, OPR_BNOT, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;
 
 
<SPAN CLASS="del">-#define getcode(fs,e)	((fs)-&gt;f-&gt;code[(e)-&gt;u.info])</SPAN>
<SPAN CLASS="add">+/* get (pointer to) instruction of given 'expdesc' */</SPAN>
<SPAN CLASS="add">+#define getinstruction(fs,e)	((fs)-&gt;f-&gt;code[(e)-&gt;u.info])</SPAN>
 
 #define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)
 

<SPAN CLASS="diff">src/lcorolib.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lcorolib.c,v 1.9 2014/11/02 19:19:04 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lcorolib.c,v 1.10 2016/04/11 19:19:55 roberto Exp $</SPAN>
 ** Coroutine Library
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -75,7 +75,7 @@</SPAN>
   lua_State *co = lua_tothread(L, lua_upvalueindex(1));
   int r = auxresume(L, co, lua_gettop(L));
   if (r &lt; 0) {
<SPAN CLASS="del">-    if (lua_isstring(L, -1)) {  /* error object is a string? */</SPAN>
<SPAN CLASS="add">+    if (lua_type(L, -1) == LUA_TSTRING) {  /* error object is a string? */</SPAN>
       luaL_where(L, 1);  /* add extra info */
       lua_insert(L, -2);
       lua_concat(L, 2);

<SPAN CLASS="diff">src/ldebug.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: ldebug.c,v 2.117 2015/11/02 18:48:07 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: ldebug.c,v 2.120 2016/03/31 19:01:21 roberto Exp $</SPAN>
 ** Debug Interface
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -69,7 +69,13 @@</SPAN>
 
 
 /*
<SPAN CLASS="del">-** this function can be called asynchronous (e.g. during a signal)</SPAN>
<SPAN CLASS="add">+** This function can be called asynchronously (e.g. during a signal).</SPAN>
<SPAN CLASS="add">+** Fields 'oldpc', 'basehookcount', and 'hookcount' (set by</SPAN>
<SPAN CLASS="add">+** 'resethookcount') are for debug only, and it is no problem if they</SPAN>
<SPAN CLASS="add">+** get arbitrary values (causes at most one wrong hook call). 'hookmask'</SPAN>
<SPAN CLASS="add">+** is an atomic value. We assume that pointers are atomic too (e.g., gcc</SPAN>
<SPAN CLASS="add">+** ensures that for all platforms where it runs). Moreover, 'hook' is</SPAN>
<SPAN CLASS="add">+** always checked before being called (see 'luaD_hook').</SPAN>
 */
 LUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
   if (func == NULL || mask == 0) {  /* turn off hooks? */

<SPAN CLASS="etc">@@ -558,7 +564,7 @@</SPAN>
 
 
 l_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
<SPAN CLASS="del">-  const char *t = objtypename(o);</SPAN>
<SPAN CLASS="add">+  const char *t = luaT_objtypename(L, o);</SPAN>
   luaG_runerror(L, "attempt to %s a %s value%s", op, t, varinfo(L, o));
 }
 

<SPAN CLASS="etc">@@ -590,9 +596,9 @@</SPAN>
 
 
 l_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
<SPAN CLASS="del">-  const char *t1 = objtypename(p1);</SPAN>
<SPAN CLASS="del">-  const char *t2 = objtypename(p2);</SPAN>
<SPAN CLASS="del">-  if (t1 == t2)</SPAN>
<SPAN CLASS="add">+  const char *t1 = luaT_objtypename(L, p1);</SPAN>
<SPAN CLASS="add">+  const char *t2 = luaT_objtypename(L, p2);</SPAN>
<SPAN CLASS="add">+  if (strcmp(t1, t2) == 0)</SPAN>
     luaG_runerror(L, "attempt to compare two %s values", t1);
   else
     luaG_runerror(L, "attempt to compare %s with %s", t1, t2);

<SPAN CLASS="diff">src/ldo.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: ldo.c,v 2.150 2015/11/19 19:16:22 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: ldo.c,v 2.151 2015/12/16 16:40:07 roberto Exp $</SPAN>
 ** Stack and Call structure of Lua
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -242,9 +242,14 @@</SPAN>
 /* }================================================================== */
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Call a hook for the given event. Make sure there is a hook to be</SPAN>
<SPAN CLASS="add">+** called. (Both 'L-&gt;hook' and 'L-&gt;hookmask', which triggers this</SPAN>
<SPAN CLASS="add">+** function, can be changed asynchronously by signals.)</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 void luaD_hook (lua_State *L, int event, int line) {
   lua_Hook hook = L-&gt;hook;
<SPAN CLASS="del">-  if (hook &amp;&amp; L-&gt;allowhook) {</SPAN>
<SPAN CLASS="add">+  if (hook &amp;&amp; L-&gt;allowhook) {  /* make sure there is a hook */</SPAN>
     CallInfo *ci = L-&gt;ci;
     ptrdiff_t top = savestack(L, L-&gt;top);
     ptrdiff_t ci_top = savestack(L, ci-&gt;top);

<SPAN CLASS="diff">src/ldo.h</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: ldo.h,v 2.28 2015/11/23 11:29:43 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: ldo.h,v 2.29 2015/12/21 13:02:14 roberto Exp $</SPAN>
 ** Stack and Call structure of Lua
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -25,7 +25,7 @@</SPAN>
 	  { pre; luaD_growstack(L, n); pos; } else { condmovestack(L,pre,pos); }
 
 /* In general, 'pre'/'pos' are empty (nothing to save) */
<SPAN CLASS="del">-#define luaD_checkstack(L,n)	luaD_checkstackaux(L,n,,)</SPAN>
<SPAN CLASS="add">+#define luaD_checkstack(L,n)	luaD_checkstackaux(L,n,(void)0,(void)0)</SPAN>
 
 
 

<SPAN CLASS="diff">src/lgc.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lgc.c,v 2.210 2015/11/03 18:10:44 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lgc.c,v 2.212 2016/03/31 19:02:03 roberto Exp $</SPAN>
 ** Garbage Collector
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -754,14 +754,11 @@</SPAN>
 /*
 ** sweep a list until a live object (or end of list)
 */
<SPAN CLASS="del">-static GCObject **sweeptolive (lua_State *L, GCObject **p, int *n) {</SPAN>
<SPAN CLASS="add">+static GCObject **sweeptolive (lua_State *L, GCObject **p) {</SPAN>
   GCObject **old = p;
<SPAN CLASS="del">-  int i = 0;</SPAN>
   do {
<SPAN CLASS="del">-    i++;</SPAN>
     p = sweeplist(L, p, 1);
   } while (p == old);
<SPAN CLASS="del">-  if (n) *n += i;</SPAN>
   return p;
 }
 

<SPAN CLASS="etc">@@ -856,10 +853,10 @@</SPAN>
 /*
 ** call all pending finalizers
 */
<SPAN CLASS="del">-static void callallpendingfinalizers (lua_State *L, int propagateerrors) {</SPAN>
<SPAN CLASS="add">+static void callallpendingfinalizers (lua_State *L) {</SPAN>
   global_State *g = G(L);
   while (g-&gt;tobefnz)
<SPAN CLASS="del">-    GCTM(L, propagateerrors);</SPAN>
<SPAN CLASS="add">+    GCTM(L, 0);</SPAN>
 }
 
 

<SPAN CLASS="etc">@@ -909,7 +906,7 @@</SPAN>
     if (issweepphase(g)) {
       makewhite(g, o);  /* "sweep" object 'o' */
       if (g-&gt;sweepgc == &amp;o-&gt;next)  /* should not remove 'sweepgc' object */
<SPAN CLASS="del">-        g-&gt;sweepgc = sweeptolive(L, g-&gt;sweepgc, NULL);  /* change 'sweepgc' */</SPAN>
<SPAN CLASS="add">+        g-&gt;sweepgc = sweeptolive(L, g-&gt;sweepgc);  /* change 'sweepgc' */</SPAN>
     }
     /* search for pointer pointing to 'o' */
     for (p = &amp;g-&gt;allgc; *p != o; p = &amp;(*p)-&gt;next) { /* empty */ }

<SPAN CLASS="etc">@@ -951,19 +948,16 @@</SPAN>
 
 /*
 ** Enter first sweep phase.
<SPAN CLASS="del">-** The call to 'sweeptolive' makes pointer point to an object inside</SPAN>
<SPAN CLASS="del">-** the list (instead of to the header), so that the real sweep do not</SPAN>
<SPAN CLASS="del">-** need to skip objects created between "now" and the start of the real</SPAN>
<SPAN CLASS="del">-** sweep.</SPAN>
<SPAN CLASS="del">-** Returns how many objects it swept.</SPAN>
<SPAN CLASS="add">+** The call to 'sweeplist' tries to make pointer point to an object</SPAN>
<SPAN CLASS="add">+** inside the list (instead of to the header), so that the real sweep do</SPAN>
<SPAN CLASS="add">+** not need to skip objects created between "now" and the start of the</SPAN>
<SPAN CLASS="add">+** real sweep.</SPAN>
 */
<SPAN CLASS="del">-static int entersweep (lua_State *L) {</SPAN>
<SPAN CLASS="add">+static void entersweep (lua_State *L) {</SPAN>
   global_State *g = G(L);
<SPAN CLASS="del">-  int n = 0;</SPAN>
   g-&gt;gcstate = GCSswpallgc;
   lua_assert(g-&gt;sweepgc == NULL);
<SPAN CLASS="del">-  g-&gt;sweepgc = sweeptolive(L, &amp;g-&gt;allgc, &amp;n);</SPAN>
<SPAN CLASS="del">-  return n;</SPAN>
<SPAN CLASS="add">+  g-&gt;sweepgc = sweeplist(L, &amp;g-&gt;allgc, 1);</SPAN>
 }
 
 

<SPAN CLASS="etc">@@ -971,7 +965,7 @@</SPAN>
   global_State *g = G(L);
   separatetobefnz(g, 1);  /* separate all objects with finalizers */
   lua_assert(g-&gt;finobj == NULL);
<SPAN CLASS="del">-  callallpendingfinalizers(L, 0);</SPAN>
<SPAN CLASS="add">+  callallpendingfinalizers(L);</SPAN>
   lua_assert(g-&gt;tobefnz == NULL);
   g-&gt;currentwhite = WHITEBITS; /* this "white" makes all objects look dead */
   g-&gt;gckind = KGC_NORMAL;

<SPAN CLASS="etc">@@ -1064,12 +1058,11 @@</SPAN>
     }
     case GCSatomic: {
       lu_mem work;
<SPAN CLASS="del">-      int sw;</SPAN>
       propagateall(g);  /* make sure gray list is empty */
       work = atomic(L);  /* work is what was traversed by 'atomic' */
<SPAN CLASS="del">-      sw = entersweep(L);</SPAN>
<SPAN CLASS="add">+      entersweep(L);</SPAN>
       g-&gt;GCestimate = gettotalbytes(g);  /* first estimate */;
<SPAN CLASS="del">-      return work + sw * GCSWEEPCOST;</SPAN>
<SPAN CLASS="add">+      return work;</SPAN>
     }
     case GCSswpallgc: {  /* sweep "regular" objects */
       return sweepstep(L, g, GCSswpfinobj, &amp;g-&gt;finobj);

<SPAN CLASS="diff">src/lgc.h</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lgc.h,v 2.90 2015/10/21 18:15:15 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lgc.h,v 2.91 2015/12/21 13:02:14 roberto Exp $</SPAN>
 ** Garbage Collector
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -112,7 +112,7 @@</SPAN>
 	  condchangemem(L,pre,pos); }
 
 /* more often than not, 'pre'/'pos' are empty */
<SPAN CLASS="del">-#define luaC_checkGC(L)		luaC_condGC(L,,)</SPAN>
<SPAN CLASS="add">+#define luaC_checkGC(L)		luaC_condGC(L,(void)0,(void)0)</SPAN>
 
 
 #define luaC_barrier(L,p,v) (  \

<SPAN CLASS="diff">src/liolib.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: liolib.c,v 2.148 2015/11/23 11:36:11 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: liolib.c,v 2.149 2016/05/02 14:03:19 roberto Exp $</SPAN>
 ** Standard I/O (and system) library
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -375,14 +375,17 @@</SPAN>
 
 
 /* maximum length of a numeral */
<SPAN CLASS="del">-#define MAXRN		200</SPAN>
<SPAN CLASS="add">+#if !defined (L_MAXLENNUM)</SPAN>
<SPAN CLASS="add">+#define L_MAXLENNUM     200</SPAN>
<SPAN CLASS="add">+#endif</SPAN>
<SPAN CLASS="add">+</SPAN>
 
 /* auxiliary structure used by 'read_number' */
 typedef struct {
   FILE *f;  /* file being read */
   int c;  /* current character (look ahead) */
   int n;  /* number of elements in buffer 'buff' */
<SPAN CLASS="del">-  char buff[MAXRN + 1];  /* +1 for ending '\0' */</SPAN>
<SPAN CLASS="add">+  char buff[L_MAXLENNUM + 1];  /* +1 for ending '\0' */</SPAN>
 } RN;
 
 

<SPAN CLASS="etc">@@ -390,7 +393,7 @@</SPAN>
 ** Add current char to buffer (if not out of space) and read next one
 */
 static int nextc (RN *rn) {
<SPAN CLASS="del">-  if (rn-&gt;n &gt;= MAXRN) {  /* buffer overflow? */</SPAN>
<SPAN CLASS="add">+  if (rn-&gt;n &gt;= L_MAXLENNUM) {  /* buffer overflow? */</SPAN>
     rn-&gt;buff[0] = '\0';  /* invalidate result */
     return 0;  /* fail */
   }

<SPAN CLASS="etc">@@ -403,10 +406,10 @@</SPAN>
 
 
 /*
<SPAN CLASS="del">-** Accept current char if it is in 'set' (of size 1 or 2)</SPAN>
<SPAN CLASS="add">+** Accept current char if it is in 'set' (of size 2)</SPAN>
 */
 static int test2 (RN *rn, const char *set) {
<SPAN CLASS="del">-  if (rn-&gt;c == set[0] || (rn-&gt;c == set[1] &amp;&amp; rn-&gt;c != '\0'))</SPAN>
<SPAN CLASS="add">+  if (rn-&gt;c == set[0] || rn-&gt;c == set[1])</SPAN>
     return nextc(rn);
   else return 0;
 }

<SPAN CLASS="etc">@@ -435,11 +438,11 @@</SPAN>
   char decp[2];
   rn.f = f; rn.n = 0;
   decp[0] = lua_getlocaledecpoint();  /* get decimal point from locale */
<SPAN CLASS="del">-  decp[1] = '\0';</SPAN>
<SPAN CLASS="add">+  decp[1] = '.';  /* always accept a dot */</SPAN>
   l_lockfile(rn.f);
   do { rn.c = l_getc(rn.f); } while (isspace(rn.c));  /* skip spaces */
   test2(&amp;rn, "-+");  /* optional signal */
<SPAN CLASS="del">-  if (test2(&amp;rn, "0")) {</SPAN>
<SPAN CLASS="add">+  if (test2(&amp;rn, "00")) {</SPAN>
     if (test2(&amp;rn, "xX")) hex = 1;  /* numeral is hexadecimal */
     else count = 1;  /* count initial '0' as a valid digit */
   }

<SPAN CLASS="diff">src/llex.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: llex.c,v 2.95 2015/11/19 19:16:22 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: llex.c,v 2.96 2016/05/02 14:02:12 roberto Exp $</SPAN>
 ** Lexical Analyzer
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -162,7 +162,6 @@</SPAN>
 void luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,
                     int firstchar) {
   ls-&gt;t.token = 0;
<SPAN CLASS="del">-  ls-&gt;decpoint = '.';</SPAN>
   ls-&gt;L = L;
   ls-&gt;current = firstchar;
   ls-&gt;lookahead.token = TK_EOS;  /* no look-ahead token */

<SPAN CLASS="etc">@@ -207,35 +206,6 @@</SPAN>
 }
 
 
<SPAN CLASS="del">-/*</SPAN>
<SPAN CLASS="del">-** change all characters 'from' in buffer to 'to'</SPAN>
<SPAN CLASS="del">-*/</SPAN>
<SPAN CLASS="del">-static void buffreplace (LexState *ls, char from, char to) {</SPAN>
<SPAN CLASS="del">-  if (from != to) {</SPAN>
<SPAN CLASS="del">-    size_t n = luaZ_bufflen(ls-&gt;buff);</SPAN>
<SPAN CLASS="del">-    char *p = luaZ_buffer(ls-&gt;buff);</SPAN>
<SPAN CLASS="del">-    while (n--)</SPAN>
<SPAN CLASS="del">-      if (p[n] == from) p[n] = to;</SPAN>
<SPAN CLASS="del">-  }</SPAN>
<SPAN CLASS="del">-}</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-/*</SPAN>
<SPAN CLASS="del">-** in case of format error, try to change decimal point separator to</SPAN>
<SPAN CLASS="del">-** the one defined in the current locale and check again</SPAN>
<SPAN CLASS="del">-*/</SPAN>
<SPAN CLASS="del">-static void trydecpoint (LexState *ls, TValue *o) {</SPAN>
<SPAN CLASS="del">-  char old = ls-&gt;decpoint;</SPAN>
<SPAN CLASS="del">-  ls-&gt;decpoint = lua_getlocaledecpoint();</SPAN>
<SPAN CLASS="del">-  buffreplace(ls, old, ls-&gt;decpoint);  /* try new decimal separator */</SPAN>
<SPAN CLASS="del">-  if (luaO_str2num(luaZ_buffer(ls-&gt;buff), o) == 0) {</SPAN>
<SPAN CLASS="del">-    /* format error with correct decimal point: no more options */</SPAN>
<SPAN CLASS="del">-    buffreplace(ls, ls-&gt;decpoint, '.');  /* undo change (for error message) */</SPAN>
<SPAN CLASS="del">-    lexerror(ls, "malformed number", TK_FLT);</SPAN>
<SPAN CLASS="del">-  }</SPAN>
<SPAN CLASS="del">-}</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-</SPAN>
 /* LUA_NUMBER */
 /*
 ** this function is quite liberal in what it accepts, as 'luaO_str2num'

<SPAN CLASS="etc">@@ -259,9 +229,8 @@</SPAN>
     else break;
   }
   save(ls, '\0');
<SPAN CLASS="del">-  buffreplace(ls, '.', ls-&gt;decpoint);  /* follow locale for decimal point */</SPAN>
   if (luaO_str2num(luaZ_buffer(ls-&gt;buff), &amp;obj) == 0)  /* format error? */
<SPAN CLASS="del">-    trydecpoint(ls, &amp;obj); /* try to update decimal point separator */</SPAN>
<SPAN CLASS="add">+    lexerror(ls, "malformed number", TK_FLT);</SPAN>
   if (ttisinteger(&amp;obj)) {
     seminfo-&gt;i = ivalue(&amp;obj);
     return TK_INT;

<SPAN CLASS="diff">src/llex.h</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: llex.h,v 1.78 2014/10/29 15:38:24 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: llex.h,v 1.79 2016/05/02 14:02:12 roberto Exp $</SPAN>
 ** Lexical Analyzer
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -69,7 +69,6 @@</SPAN>
   struct Dyndata *dyd;  /* dynamic structures used by the parser */
   TString *source;  /* current source name */
   TString *envn;  /* environment variable name */
<SPAN CLASS="del">-  char decpoint;  /* locale decimal point */</SPAN>
 } LexState;
 
 

<SPAN CLASS="diff">src/lobject.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lobject.c,v 2.108 2015/11/02 16:09:30 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lobject.c,v 2.111 2016/05/20 14:07:48 roberto Exp $</SPAN>
 ** Some generic functions over Lua objects
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -243,20 +243,59 @@</SPAN>
 /* }====================================================== */
 
 
<SPAN CLASS="del">-static const char *l_str2d (const char *s, lua_Number *result) {</SPAN>
<SPAN CLASS="add">+/* maximum length of a numeral */</SPAN>
<SPAN CLASS="add">+#if !defined (L_MAXLENNUM)</SPAN>
<SPAN CLASS="add">+#define L_MAXLENNUM	200</SPAN>
<SPAN CLASS="add">+#endif</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+static const char *l_str2dloc (const char *s, lua_Number *result, int mode) {</SPAN>
   char *endptr;
<SPAN CLASS="del">-  if (strpbrk(s, "nN"))  /* reject 'inf' and 'nan' */</SPAN>
<SPAN CLASS="add">+  *result = (mode == 'x') ? lua_strx2number(s, &amp;endptr)  /* try to convert */</SPAN>
<SPAN CLASS="add">+                          : lua_str2number(s, &amp;endptr);</SPAN>
<SPAN CLASS="add">+  if (endptr == s) return NULL;  /* nothing recognized? */</SPAN>
<SPAN CLASS="add">+  while (lisspace(cast_uchar(*endptr))) endptr++;  /* skip trailing spaces */</SPAN>
<SPAN CLASS="add">+  return (*endptr == '\0') ? endptr : NULL;  /* OK if no trailing characters */</SPAN>
<SPAN CLASS="add">+}</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Convert string 's' to a Lua number (put in 'result'). Return NULL</SPAN>
<SPAN CLASS="add">+** on fail or the address of the ending '\0' on success.</SPAN>
<SPAN CLASS="add">+** 'pmode' points to (and 'mode' contains) special things in the string:</SPAN>
<SPAN CLASS="add">+** - 'x'/'X' means an hexadecimal numeral</SPAN>
<SPAN CLASS="add">+** - 'n'/'N' means 'inf' or 'nan' (which should be rejected)</SPAN>
<SPAN CLASS="add">+** - '.' just optimizes the search for the common case (nothing special)</SPAN>
<SPAN CLASS="add">+** This function accepts both the current locale or a dot as the radix</SPAN>
<SPAN CLASS="add">+** mark. If the convertion fails, it may mean number has a dot but</SPAN>
<SPAN CLASS="add">+** locale accepts something else. In that case, the code copies 's'</SPAN>
<SPAN CLASS="add">+** to a buffer (because 's' is read-only), changes the dot to the</SPAN>
<SPAN CLASS="add">+** current locale radix mark, and tries to convert again.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
<SPAN CLASS="add">+static const char *l_str2d (const char *s, lua_Number *result) {</SPAN>
<SPAN CLASS="add">+  const char *endptr;</SPAN>
<SPAN CLASS="add">+  const char *pmode = strpbrk(s, ".xXnN");</SPAN>
<SPAN CLASS="add">+  int mode = pmode ? ltolower(cast_uchar(*pmode)) : 0;</SPAN>
<SPAN CLASS="add">+  if (mode == 'n')  /* reject 'inf' and 'nan' */</SPAN>
     return NULL;
<SPAN CLASS="del">-  else if (strpbrk(s, "xX"))  /* hex? */</SPAN>
<SPAN CLASS="del">-    *result = lua_strx2number(s, &amp;endptr);</SPAN>
<SPAN CLASS="del">-  else</SPAN>
<SPAN CLASS="del">-    *result = lua_str2number(s, &amp;endptr);</SPAN>
<SPAN CLASS="del">-  if (endptr == s) return NULL;  /* nothing recognized */</SPAN>
<SPAN CLASS="del">-  while (lisspace(cast_uchar(*endptr))) endptr++;</SPAN>
<SPAN CLASS="del">-  return (*endptr == '\0' ? endptr : NULL);  /* OK if no trailing characters */</SPAN>
<SPAN CLASS="add">+  endptr = l_str2dloc(s, result, mode);  /* try to convert */</SPAN>
<SPAN CLASS="add">+  if (endptr == NULL) {  /* failed? may be a different locale */</SPAN>
<SPAN CLASS="add">+    char buff[L_MAXLENNUM + 1];</SPAN>
<SPAN CLASS="add">+    char *pdot = strchr(s, '.');</SPAN>
<SPAN CLASS="add">+    if (strlen(s) &gt; L_MAXLENNUM || pdot == NULL)</SPAN>
<SPAN CLASS="add">+      return NULL;  /* string too long or no dot; fail */</SPAN>
<SPAN CLASS="add">+    strcpy(buff, s);  /* copy string to buffer */</SPAN>
<SPAN CLASS="add">+    buff[pdot - s] = lua_getlocaledecpoint();  /* correct decimal point */</SPAN>
<SPAN CLASS="add">+    endptr = l_str2dloc(buff, result, mode);  /* try again */</SPAN>
<SPAN CLASS="add">+    if (endptr != NULL)</SPAN>
<SPAN CLASS="add">+      endptr = s + (endptr - buff);  /* make relative to 's' */</SPAN>
<SPAN CLASS="add">+  }</SPAN>
<SPAN CLASS="add">+  return endptr;</SPAN>
 }
 
 
<SPAN CLASS="add">+#define MAXBY10		cast(lua_Unsigned, LUA_MAXINTEGER / 10)</SPAN>
<SPAN CLASS="add">+#define MAXLASTD	cast_int(LUA_MAXINTEGER % 10)</SPAN>
<SPAN CLASS="add">+</SPAN>
 static const char *l_str2int (const char *s, lua_Integer *result) {
   lua_Unsigned a = 0;
   int empty = 1;

<SPAN CLASS="etc">@@ -273,7 +312,10 @@</SPAN>
   }
   else {  /* decimal */
     for (; lisdigit(cast_uchar(*s)); s++) {
<SPAN CLASS="del">-      a = a * 10 + *s - '0';</SPAN>
<SPAN CLASS="add">+      int d = *s - '0';</SPAN>
<SPAN CLASS="add">+      if (a &gt;= MAXBY10 &amp;&amp; (a &gt; MAXBY10 || d &gt; MAXLASTD + neg))  /* overflow? */</SPAN>
<SPAN CLASS="add">+        return NULL;  /* do not accept it (as integer) */</SPAN>
<SPAN CLASS="add">+      a = a * 10 + d;</SPAN>
       empty = 0;
     }
   }

<SPAN CLASS="etc">@@ -351,8 +393,10 @@</SPAN>
 }
 
 
<SPAN CLASS="del">-/* this function handles only '%d', '%c', '%f', '%p', and '%s' </SPAN>
<SPAN CLASS="del">-   conventional formats, plus Lua-specific '%I' and '%U' */</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** this function handles only '%d', '%c', '%f', '%p', and '%s' </SPAN>
<SPAN CLASS="add">+   conventional formats, plus Lua-specific '%I' and '%U'</SPAN>
<SPAN CLASS="add">+*/</SPAN>
 const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
   int n = 0;
   for (;;) {

<SPAN CLASS="etc">@@ -360,13 +404,13 @@</SPAN>
     if (e == NULL) break;
     pushstr(L, fmt, e - fmt);
     switch (*(e+1)) {
<SPAN CLASS="del">-      case 's': {</SPAN>
<SPAN CLASS="add">+      case 's': {  /* zero-terminated string */</SPAN>
         const char *s = va_arg(argp, char *);
         if (s == NULL) s = "(null)";
         pushstr(L, s, strlen(s));
         break;
       }
<SPAN CLASS="del">-      case 'c': {</SPAN>
<SPAN CLASS="add">+      case 'c': {  /* an 'int' as a character */</SPAN>
         char buff = cast(char, va_arg(argp, int));
         if (lisprint(cast_uchar(buff)))
           pushstr(L, &amp;buff, 1);

<SPAN CLASS="etc">@@ -374,28 +418,28 @@</SPAN>
           luaO_pushfstring(L, "&lt;\\%d&gt;", cast_uchar(buff));
         break;
       }
<SPAN CLASS="del">-      case 'd': {</SPAN>
<SPAN CLASS="add">+      case 'd': {  /* an 'int' */</SPAN>
         setivalue(L-&gt;top, va_arg(argp, int));
         goto top2str;
       }
<SPAN CLASS="del">-      case 'I': {</SPAN>
<SPAN CLASS="add">+      case 'I': {  /* a 'lua_Integer' */</SPAN>
         setivalue(L-&gt;top, cast(lua_Integer, va_arg(argp, l_uacInt)));
         goto top2str;
       }
<SPAN CLASS="del">-      case 'f': {</SPAN>
<SPAN CLASS="add">+      case 'f': {  /* a 'lua_Number' */</SPAN>
         setfltvalue(L-&gt;top, cast_num(va_arg(argp, l_uacNumber)));
<SPAN CLASS="del">-      top2str:</SPAN>
<SPAN CLASS="add">+      top2str:  /* convert the top element to a string */</SPAN>
         luaD_inctop(L);
         luaO_tostring(L, L-&gt;top - 1);
         break;
       }
<SPAN CLASS="del">-      case 'p': {</SPAN>
<SPAN CLASS="add">+      case 'p': {  /* a pointer */</SPAN>
         char buff[4*sizeof(void *) + 8]; /* should be enough space for a '%p' */
         int l = l_sprintf(buff, sizeof(buff), "%p", va_arg(argp, void *));
         pushstr(L, buff, l);
         break;
       }
<SPAN CLASS="del">-      case 'U': {</SPAN>
<SPAN CLASS="add">+      case 'U': {  /* an 'int' as a UTF-8 sequence */</SPAN>
         char buff[UTF8BUFFSZ];
         int l = luaO_utf8esc(buff, cast(long, va_arg(argp, long)));
         pushstr(L, buff + UTF8BUFFSZ - l, l);

<SPAN CLASS="diff">src/loslib.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: loslib.c,v 1.60 2015/11/19 19:16:22 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: loslib.c,v 1.64 2016/04/18 13:06:55 roberto Exp $</SPAN>
 ** Standard Operating System library
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -24,18 +24,29 @@</SPAN>
 
 /*
 ** {==================================================================
<SPAN CLASS="del">-** list of valid conversion specifiers for the 'strftime' function</SPAN>
<SPAN CLASS="add">+** List of valid conversion specifiers for the 'strftime' function;</SPAN>
<SPAN CLASS="add">+** options are grouped by length; group of length 2 start with '||'.</SPAN>
 ** ===================================================================
 */
 #if !defined(LUA_STRFTIMEOPTIONS)	/* { */
 
<SPAN CLASS="del">-#if defined(LUA_USE_C89)</SPAN>
<SPAN CLASS="del">-#define LUA_STRFTIMEOPTIONS	{ "aAbBcdHIjmMpSUwWxXyYz%", "" }</SPAN>
<SPAN CLASS="add">+/* options for ANSI C 89 */</SPAN>
<SPAN CLASS="add">+#define L_STRFTIMEC89		"aAbBcdHIjmMpSUwWxXyYZ%"</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+/* options for ISO C 99 and POSIX */</SPAN>
<SPAN CLASS="add">+#define L_STRFTIMEC99 "aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%" \</SPAN>
<SPAN CLASS="add">+	"||" "EcECExEXEyEY" "OdOeOHOIOmOMOSOuOUOVOwOWOy"</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+/* options for Windows */</SPAN>
<SPAN CLASS="add">+#define L_STRFTIMEWIN "aAbBcdHIjmMpSUwWxXyYzZ%" \</SPAN>
<SPAN CLASS="add">+	"||" "#c#x#d#H#I#j#m#M#S#U#w#W#y#Y"</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+#if defined(LUA_USE_WINDOWS)</SPAN>
<SPAN CLASS="add">+#define LUA_STRFTIMEOPTIONS	L_STRFTIMEWIN</SPAN>
<SPAN CLASS="add">+#elif defined(LUA_USE_C89)</SPAN>
<SPAN CLASS="add">+#define LUA_STRFTIMEOPTIONS	L_STRFTIMEC89</SPAN>
 #else  /* C99 specification */
<SPAN CLASS="del">-#define LUA_STRFTIMEOPTIONS \</SPAN>
<SPAN CLASS="del">-	{ "aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%", "", \</SPAN>
<SPAN CLASS="del">-	  "E", "cCxXyY",  \</SPAN>
<SPAN CLASS="del">-	  "O", "deHImMSuUVwWy" }</SPAN>
<SPAN CLASS="add">+#define LUA_STRFTIMEOPTIONS	L_STRFTIMEC99</SPAN>
 #endif
 
 #endif					/* } */

<SPAN CLASS="etc">@@ -195,6 +206,23 @@</SPAN>
   lua_setfield(L, -2, key);
 }
 
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Set all fields from structure 'tm' in the table on top of the stack</SPAN>
<SPAN CLASS="add">+*/</SPAN>
<SPAN CLASS="add">+static void setallfields (lua_State *L, struct tm *stm) {</SPAN>
<SPAN CLASS="add">+  setfield(L, "sec", stm-&gt;tm_sec);</SPAN>
<SPAN CLASS="add">+  setfield(L, "min", stm-&gt;tm_min);</SPAN>
<SPAN CLASS="add">+  setfield(L, "hour", stm-&gt;tm_hour);</SPAN>
<SPAN CLASS="add">+  setfield(L, "day", stm-&gt;tm_mday);</SPAN>
<SPAN CLASS="add">+  setfield(L, "month", stm-&gt;tm_mon + 1);</SPAN>
<SPAN CLASS="add">+  setfield(L, "year", stm-&gt;tm_year + 1900);</SPAN>
<SPAN CLASS="add">+  setfield(L, "wday", stm-&gt;tm_wday + 1);</SPAN>
<SPAN CLASS="add">+  setfield(L, "yday", stm-&gt;tm_yday + 1);</SPAN>
<SPAN CLASS="add">+  setboolfield(L, "isdst", stm-&gt;tm_isdst);</SPAN>
<SPAN CLASS="add">+}</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
 static int getboolfield (lua_State *L, const char *key) {
   int res;
   res = (lua_getfield(L, -1, key) == LUA_TNIL) ? -1 : lua_toboolean(L, -1);

<SPAN CLASS="etc">@@ -210,18 +238,18 @@</SPAN>
 
 static int getfield (lua_State *L, const char *key, int d, int delta) {
   int isnum;
<SPAN CLASS="del">-  int t = lua_getfield(L, -1, key);</SPAN>
<SPAN CLASS="add">+  int t = lua_getfield(L, -1, key);  /* get field and its type */</SPAN>
   lua_Integer res = lua_tointegerx(L, -1, &amp;isnum);
<SPAN CLASS="del">-  if (!isnum) {  /* field is not a number? */</SPAN>
<SPAN CLASS="add">+  if (!isnum) {  /* field is not an integer? */</SPAN>
     if (t != LUA_TNIL)  /* some other value? */
<SPAN CLASS="del">-      return luaL_error(L, "field '%s' not an integer", key);</SPAN>
<SPAN CLASS="add">+      return luaL_error(L, "field '%s' is not an integer", key);</SPAN>
     else if (d &lt; 0)  /* absent field; no default? */
       return luaL_error(L, "field '%s' missing in date table", key);
     res = d;
   }
   else {
     if (!(-L_MAXDATEFIELD &lt;= res &amp;&amp; res &lt;= L_MAXDATEFIELD))
<SPAN CLASS="del">-      return luaL_error(L, "field '%s' out-of-bounds", key);</SPAN>
<SPAN CLASS="add">+      return luaL_error(L, "field '%s' is out-of-bound", key);</SPAN>
     res -= delta;
   }
   lua_pop(L, 1);

<SPAN CLASS="etc">@@ -230,21 +258,15 @@</SPAN>
 
 
 static const char *checkoption (lua_State *L, const char *conv, char *buff) {
<SPAN CLASS="del">-  static const char *const options[] = LUA_STRFTIMEOPTIONS;</SPAN>
<SPAN CLASS="del">-  unsigned int i;</SPAN>
<SPAN CLASS="del">-  for (i = 0; i &lt; sizeof(options)/sizeof(options[0]); i += 2) {</SPAN>
<SPAN CLASS="del">-    if (*conv != '\0' &amp;&amp; strchr(options[i], *conv) != NULL) {</SPAN>
<SPAN CLASS="del">-      buff[1] = *conv;</SPAN>
<SPAN CLASS="del">-      if (*options[i + 1] == '\0') {  /* one-char conversion specifier? */</SPAN>
<SPAN CLASS="del">-        buff[2] = '\0';  /* end buffer */</SPAN>
<SPAN CLASS="del">-        return conv + 1;</SPAN>
<SPAN CLASS="del">-      }</SPAN>
<SPAN CLASS="del">-      else if (*(conv + 1) != '\0' &amp;&amp;</SPAN>
<SPAN CLASS="del">-               strchr(options[i + 1], *(conv + 1)) != NULL) {</SPAN>
<SPAN CLASS="del">-        buff[2] = *(conv + 1);  /* valid two-char conversion specifier */</SPAN>
<SPAN CLASS="del">-        buff[3] = '\0';  /* end buffer */</SPAN>
<SPAN CLASS="del">-        return conv + 2;</SPAN>
<SPAN CLASS="del">-      }</SPAN>
<SPAN CLASS="add">+  const char *option;</SPAN>
<SPAN CLASS="add">+  int oplen = 1;</SPAN>
<SPAN CLASS="add">+  for (option = LUA_STRFTIMEOPTIONS; *option != '\0'; option += oplen) {</SPAN>
<SPAN CLASS="add">+    if (*option == '|')  /* next block? */</SPAN>
<SPAN CLASS="add">+      oplen++;  /* next length */</SPAN>
<SPAN CLASS="add">+    else if (memcmp(conv, option, oplen) == 0) {  /* match? */</SPAN>
<SPAN CLASS="add">+      memcpy(buff, conv, oplen);  /* copy valid option to buffer */</SPAN>
<SPAN CLASS="add">+      buff[oplen] = '\0';</SPAN>
<SPAN CLASS="add">+      return conv + oplen;  /* return next item */</SPAN>
     }
   }
   luaL_argerror(L, 1,

<SPAN CLASS="etc">@@ -271,18 +293,10 @@</SPAN>
     luaL_error(L, "time result cannot be represented in this installation");
   if (strcmp(s, "*t") == 0) {
     lua_createtable(L, 0, 9);  /* 9 = number of fields */
<SPAN CLASS="del">-    setfield(L, "sec", stm-&gt;tm_sec);</SPAN>
<SPAN CLASS="del">-    setfield(L, "min", stm-&gt;tm_min);</SPAN>
<SPAN CLASS="del">-    setfield(L, "hour", stm-&gt;tm_hour);</SPAN>
<SPAN CLASS="del">-    setfield(L, "day", stm-&gt;tm_mday);</SPAN>
<SPAN CLASS="del">-    setfield(L, "month", stm-&gt;tm_mon+1);</SPAN>
<SPAN CLASS="del">-    setfield(L, "year", stm-&gt;tm_year+1900);</SPAN>
<SPAN CLASS="del">-    setfield(L, "wday", stm-&gt;tm_wday+1);</SPAN>
<SPAN CLASS="del">-    setfield(L, "yday", stm-&gt;tm_yday+1);</SPAN>
<SPAN CLASS="del">-    setboolfield(L, "isdst", stm-&gt;tm_isdst);</SPAN>
<SPAN CLASS="add">+    setallfields(L, stm);</SPAN>
   }
   else {
<SPAN CLASS="del">-    char cc[4];</SPAN>
<SPAN CLASS="add">+    char cc[4];  /* buffer for individual conversion specifiers */</SPAN>
     luaL_Buffer b;
     cc[0] = '%';
     luaL_buffinit(L, &amp;b);

<SPAN CLASS="etc">@@ -292,7 +306,7 @@</SPAN>
       else {
         size_t reslen;
         char *buff = luaL_prepbuffsize(&amp;b, SIZETIMEFMT);
<SPAN CLASS="del">-        s = checkoption(L, s + 1, cc);</SPAN>
<SPAN CLASS="add">+        s = checkoption(L, s + 1, cc + 1);  /* copy specifier to 'cc' */</SPAN>
         reslen = strftime(buff, SIZETIMEFMT, cc, stm);
         luaL_addsize(&amp;b, reslen);
       }

<SPAN CLASS="etc">@@ -319,6 +333,7 @@</SPAN>
     ts.tm_year = getfield(L, "year", -1, 1900);
     ts.tm_isdst = getboolfield(L, "isdst");
     t = mktime(&amp;ts);
<SPAN CLASS="add">+    setallfields(L, &amp;ts);  /* update fields with normalized values */</SPAN>
   }
   if (t != (time_t)(l_timet)t || t == (time_t)(-1))
     luaL_error(L, "time result cannot be represented in this installation");

<SPAN CLASS="diff">src/lparser.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lparser.c,v 2.149 2015/11/02 16:09:30 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lparser.c,v 2.153 2016/05/13 19:10:16 roberto Exp $</SPAN>
 ** Lua Parser
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -164,7 +164,8 @@</SPAN>
   int oldsize = f-&gt;sizelocvars;
   luaM_growvector(ls-&gt;L, f-&gt;locvars, fs-&gt;nlocvars, f-&gt;sizelocvars,
                   LocVar, SHRT_MAX, "local variables");
<SPAN CLASS="del">-  while (oldsize &lt; f-&gt;sizelocvars) f-&gt;locvars[oldsize++].varname = NULL;</SPAN>
<SPAN CLASS="add">+  while (oldsize &lt; f-&gt;sizelocvars)</SPAN>
<SPAN CLASS="add">+    f-&gt;locvars[oldsize++].varname = NULL;</SPAN>
   f-&gt;locvars[fs-&gt;nlocvars].varname = varname;
   luaC_objbarrier(ls-&gt;L, f, varname);
   return fs-&gt;nlocvars++;

<SPAN CLASS="etc">@@ -230,7 +231,8 @@</SPAN>
   checklimit(fs, fs-&gt;nups + 1, MAXUPVAL, "upvalues");
   luaM_growvector(fs-&gt;ls-&gt;L, f-&gt;upvalues, fs-&gt;nups, f-&gt;sizeupvalues,
                   Upvaldesc, MAXUPVAL, "upvalues");
<SPAN CLASS="del">-  while (oldsize &lt; f-&gt;sizeupvalues) f-&gt;upvalues[oldsize++].name = NULL;</SPAN>
<SPAN CLASS="add">+  while (oldsize &lt; f-&gt;sizeupvalues)</SPAN>
<SPAN CLASS="add">+    f-&gt;upvalues[oldsize++].name = NULL;</SPAN>
   f-&gt;upvalues[fs-&gt;nups].instack = (v-&gt;k == VLOCAL);
   f-&gt;upvalues[fs-&gt;nups].idx = cast_byte(v-&gt;u.info);
   f-&gt;upvalues[fs-&gt;nups].name = name;

<SPAN CLASS="etc">@@ -255,7 +257,8 @@</SPAN>
 */
 static void markupval (FuncState *fs, int level) {
   BlockCnt *bl = fs-&gt;bl;
<SPAN CLASS="del">-  while (bl-&gt;nactvar &gt; level) bl = bl-&gt;previous;</SPAN>
<SPAN CLASS="add">+  while (bl-&gt;nactvar &gt; level)</SPAN>
<SPAN CLASS="add">+    bl = bl-&gt;previous;</SPAN>
   bl-&gt;upval = 1;
 }
 

<SPAN CLASS="etc">@@ -264,27 +267,26 @@</SPAN>
   Find variable with given name 'n'. If it is an upvalue, add this
   upvalue into all intermediate functions.
 */
<SPAN CLASS="del">-static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {</SPAN>
<SPAN CLASS="add">+static void singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {</SPAN>
   if (fs == NULL)  /* no more levels? */
<SPAN CLASS="del">-    return VVOID;  /* default is global */</SPAN>
<SPAN CLASS="add">+    init_exp(var, VVOID, 0);  /* default is global */</SPAN>
   else {
     int v = searchvar(fs, n);  /* look up locals at current level */
     if (v &gt;= 0) {  /* found? */
       init_exp(var, VLOCAL, v);  /* variable is local */
       if (!base)
         markupval(fs, v);  /* local will be used as an upval */
<SPAN CLASS="del">-      return VLOCAL;</SPAN>
     }
     else {  /* not found as local at current level; try upvalues */
       int idx = searchupvalue(fs, n);  /* try existing upvalues */
       if (idx &lt; 0) {  /* not found? */
<SPAN CLASS="del">-        if (singlevaraux(fs-&gt;prev, n, var, 0) == VVOID) /* try upper levels */</SPAN>
<SPAN CLASS="del">-          return VVOID;  /* not found; is a global */</SPAN>
<SPAN CLASS="add">+        singlevaraux(fs-&gt;prev, n, var, 0);  /* try upper levels */</SPAN>
<SPAN CLASS="add">+        if (var-&gt;k == VVOID)  /* not found? */</SPAN>
<SPAN CLASS="add">+          return;  /* it is a global */</SPAN>
         /* else was LOCAL or UPVAL */
         idx  = newupvalue(fs, n, var);  /* will be a new upvalue */
       }
<SPAN CLASS="del">-      init_exp(var, VUPVAL, idx);</SPAN>
<SPAN CLASS="del">-      return VUPVAL;</SPAN>
<SPAN CLASS="add">+      init_exp(var, VUPVAL, idx);  /* new or old upvalue */</SPAN>
     }
   }
 }

<SPAN CLASS="etc">@@ -293,10 +295,11 @@</SPAN>
 static void singlevar (LexState *ls, expdesc *var) {
   TString *varname = str_checkname(ls);
   FuncState *fs = ls-&gt;fs;
<SPAN CLASS="del">-  if (singlevaraux(fs, varname, var, 1) == VVOID) {  /* global name? */</SPAN>
<SPAN CLASS="add">+  singlevaraux(fs, varname, var, 1);</SPAN>
<SPAN CLASS="add">+  if (var-&gt;k == VVOID) {  /* global name? */</SPAN>
     expdesc key;
     singlevaraux(fs, ls-&gt;envn, var, 1);  /* get environment variable */
<SPAN CLASS="del">-    lua_assert(var-&gt;k == VLOCAL || var-&gt;k == VUPVAL);</SPAN>
<SPAN CLASS="add">+    lua_assert(var-&gt;k != VVOID);  /* this one must exist */</SPAN>
     codestring(ls, &amp;key, varname);  /* key is variable name */
     luaK_indexed(fs, var, &amp;key);  /* env[varname] */
   }

<SPAN CLASS="etc">@@ -499,7 +502,8 @@</SPAN>
   if (fs-&gt;np &gt;= f-&gt;sizep) {
     int oldsize = f-&gt;sizep;
     luaM_growvector(L, f-&gt;p, fs-&gt;np, f-&gt;sizep, Proto *, MAXARG_Bx, "functions");
<SPAN CLASS="del">-    while (oldsize &lt; f-&gt;sizep) f-&gt;p[oldsize++] = NULL;</SPAN>
<SPAN CLASS="add">+    while (oldsize &lt; f-&gt;sizep)</SPAN>
<SPAN CLASS="add">+      f-&gt;p[oldsize++] = NULL;</SPAN>
   }
   f-&gt;p[fs-&gt;np++] = clp = luaF_newproto(L);
   luaC_objbarrier(L, f, clp);

<SPAN CLASS="etc">@@ -1226,7 +1230,7 @@</SPAN>
   checkrepeated(fs, ll, label);  /* check for repeated labels */
   checknext(ls, TK_DBCOLON);  /* skip double colon */
   /* create new entry for this label */
<SPAN CLASS="del">-  l = newlabelentry(ls, ll, label, line, fs-&gt;pc);</SPAN>
<SPAN CLASS="add">+  l = newlabelentry(ls, ll, label, line, luaK_getlabel(fs));</SPAN>
   skipnoopstat(ls);  /* skip other no-op statements */
   if (block_follow(ls, 0)) {  /* label is last no-op statement in the block? */
     /* assume that locals are already out of scope */

<SPAN CLASS="etc">@@ -1494,7 +1498,7 @@</SPAN>
   }
   else {  /* stat -&gt; func */
     check_condition(ls, v.v.k == VCALL, "syntax error");
<SPAN CLASS="del">-    SETARG_C(getcode(fs, &amp;v.v), 1);  /* call statement uses no results */</SPAN>
<SPAN CLASS="add">+    SETARG_C(getinstruction(fs, &amp;v.v), 1);  /* call statement uses no results */</SPAN>
   }
 }
 

<SPAN CLASS="etc">@@ -1511,8 +1515,8 @@</SPAN>
     if (hasmultret(e.k)) {
       luaK_setmultret(fs, &amp;e);
       if (e.k == VCALL &amp;&amp; nret == 1) {  /* tail call? */
<SPAN CLASS="del">-        SET_OPCODE(getcode(fs,&amp;e), OP_TAILCALL);</SPAN>
<SPAN CLASS="del">-        lua_assert(GETARG_A(getcode(fs,&amp;e)) == fs-&gt;nactvar);</SPAN>
<SPAN CLASS="add">+        SET_OPCODE(getinstruction(fs,&amp;e), OP_TAILCALL);</SPAN>
<SPAN CLASS="add">+        lua_assert(GETARG_A(getinstruction(fs,&amp;e)) == fs-&gt;nactvar);</SPAN>
       }
       first = fs-&gt;nactvar;
       nret = LUA_MULTRET;  /* return all values */

<SPAN CLASS="diff">src/lparser.h</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lparser.h,v 1.74 2014/10/25 11:50:46 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lparser.h,v 1.76 2015/12/30 18:16:13 roberto Exp $</SPAN>
 ** Lua Parser
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -13,25 +13,38 @@</SPAN>
 
 
 /*
<SPAN CLASS="del">-** Expression descriptor</SPAN>
<SPAN CLASS="add">+** Expression and variable descriptor.</SPAN>
<SPAN CLASS="add">+** Code generation for variables and expressions can be delayed to allow</SPAN>
<SPAN CLASS="add">+** optimizations; An 'expdesc' structure describes a potentially-delayed</SPAN>
<SPAN CLASS="add">+** variable/expression. It has a description of its "main" value plus a</SPAN>
<SPAN CLASS="add">+** list of conditional jumps that can also produce its value (generated</SPAN>
<SPAN CLASS="add">+** by short-circuit operators 'and'/'or').</SPAN>
 */
 
<SPAN CLASS="add">+/* kinds of variables/expressions */</SPAN>
 typedef enum {
<SPAN CLASS="del">-  VVOID,	/* no value */</SPAN>
<SPAN CLASS="del">-  VNIL,</SPAN>
<SPAN CLASS="del">-  VTRUE,</SPAN>
<SPAN CLASS="del">-  VFALSE,</SPAN>
<SPAN CLASS="del">-  VK,		/* info = index of constant in 'k' */</SPAN>
<SPAN CLASS="del">-  VKFLT,	/* nval = numerical float value */</SPAN>
<SPAN CLASS="del">-  VKINT,	/* nval = numerical integer value */</SPAN>
<SPAN CLASS="del">-  VNONRELOC,	/* info = result register */</SPAN>
<SPAN CLASS="del">-  VLOCAL,	/* info = local register */</SPAN>
<SPAN CLASS="del">-  VUPVAL,       /* info = index of upvalue in 'upvalues' */</SPAN>
<SPAN CLASS="del">-  VINDEXED,	/* t = table register/upvalue; idx = index R/K */</SPAN>
<SPAN CLASS="del">-  VJMP,		/* info = instruction pc */</SPAN>
<SPAN CLASS="del">-  VRELOCABLE,	/* info = instruction pc */</SPAN>
<SPAN CLASS="del">-  VCALL,	/* info = instruction pc */</SPAN>
<SPAN CLASS="del">-  VVARARG	/* info = instruction pc */</SPAN>
<SPAN CLASS="add">+  VVOID,  /* when 'expdesc' describes the last expression a list,</SPAN>
<SPAN CLASS="add">+             this kind means an empty list (so, no expression) */</SPAN>
<SPAN CLASS="add">+  VNIL,  /* constant nil */</SPAN>
<SPAN CLASS="add">+  VTRUE,  /* constant true */</SPAN>
<SPAN CLASS="add">+  VFALSE,  /* constant false */</SPAN>
<SPAN CLASS="add">+  VK,  /* constant in 'k'; info = index of constant in 'k' */</SPAN>
<SPAN CLASS="add">+  VKFLT,  /* floating constant; nval = numerical float value */</SPAN>
<SPAN CLASS="add">+  VKINT,  /* integer constant; nval = numerical integer value */</SPAN>
<SPAN CLASS="add">+  VNONRELOC,  /* expression has its value in a fixed register;</SPAN>
<SPAN CLASS="add">+                 info = result register */</SPAN>
<SPAN CLASS="add">+  VLOCAL,  /* local variable; info = local register */</SPAN>
<SPAN CLASS="add">+  VUPVAL,  /* upvalue variable; info = index of upvalue in 'upvalues' */</SPAN>
<SPAN CLASS="add">+  VINDEXED,  /* indexed variable;</SPAN>
<SPAN CLASS="add">+                ind.vt = whether 't' is register or upvalue;</SPAN>
<SPAN CLASS="add">+                ind.t = table register or upvalue;</SPAN>
<SPAN CLASS="add">+                ind.idx = key's R/K index */</SPAN>
<SPAN CLASS="add">+  VJMP,  /* expression is a test/comparison;</SPAN>
<SPAN CLASS="add">+            info = pc of corresponding jump instruction */</SPAN>
<SPAN CLASS="add">+  VRELOCABLE,  /* expression can put result in any register;</SPAN>
<SPAN CLASS="add">+                  info = instruction pc */</SPAN>
<SPAN CLASS="add">+  VCALL,  /* expression is a function call; info = instruction pc */</SPAN>
<SPAN CLASS="add">+  VVARARG  /* vararg expression; info = instruction pc */</SPAN>
 } expkind;
 
 

<SPAN CLASS="etc">@@ -41,14 +54,14 @@</SPAN>
 typedef struct expdesc {
   expkind k;
   union {
<SPAN CLASS="add">+    lua_Integer ival;    /* for VKINT */</SPAN>
<SPAN CLASS="add">+    lua_Number nval;  /* for VKFLT */</SPAN>
<SPAN CLASS="add">+    int info;  /* for generic use */</SPAN>
     struct {  /* for indexed variables (VINDEXED) */
       short idx;  /* index (R/K) */
       lu_byte t;  /* table (register or upvalue) */
       lu_byte vt;  /* whether 't' is register (VLOCAL) or upvalue (VUPVAL) */
     } ind;
<SPAN CLASS="del">-    int info;  /* for generic use */</SPAN>
<SPAN CLASS="del">-    lua_Number nval;  /* for VKFLT */</SPAN>
<SPAN CLASS="del">-    lua_Integer ival;    /* for VKINT */</SPAN>
   } u;
   int t;  /* patch list of 'exit when true' */
   int f;  /* patch list of 'exit when false' */

<SPAN CLASS="diff">src/lstate.h</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lstate.h,v 2.128 2015/11/13 12:16:51 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lstate.h,v 2.130 2015/12/16 16:39:38 roberto Exp $</SPAN>
 ** Global State
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -33,6 +33,15 @@</SPAN>
 struct lua_longjmp;  /* defined in ldo.c */
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Atomic type (relative to signals) to better ensure that 'lua_sethook' </SPAN>
<SPAN CLASS="add">+** is thread safe</SPAN>
<SPAN CLASS="add">+*/</SPAN>
<SPAN CLASS="add">+#if !defined(l_signalT)</SPAN>
<SPAN CLASS="add">+#include &lt;signal.h&gt;</SPAN>
<SPAN CLASS="add">+#define l_signalT	sig_atomic_t</SPAN>
<SPAN CLASS="add">+#endif</SPAN>
<SPAN CLASS="add">+</SPAN>
 
 /* extra stack space to handle TM calls and some other extras */
 #define EXTRA_STACK   5

<SPAN CLASS="etc">@@ -162,14 +171,14 @@</SPAN>
   struct lua_State *twups;  /* list of threads with open upvalues */
   struct lua_longjmp *errorJmp;  /* current error recover point */
   CallInfo base_ci;  /* CallInfo for first level (C calling Lua) */
<SPAN CLASS="del">-  lua_Hook hook;</SPAN>
<SPAN CLASS="add">+  volatile lua_Hook hook;</SPAN>
   ptrdiff_t errfunc;  /* current error handling function (stack index) */
   int stacksize;
   int basehookcount;
   int hookcount;
   unsigned short nny;  /* number of non-yieldable calls in stack */
   unsigned short nCcalls;  /* number of nested C calls */
<SPAN CLASS="del">-  lu_byte hookmask;</SPAN>
<SPAN CLASS="add">+  l_signalT hookmask;</SPAN>
   lu_byte allowhook;
 };
 

<SPAN CLASS="diff">src/lstrlib.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lstrlib.c,v 1.239 2015/11/25 16:28:17 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lstrlib.c,v 1.251 2016/05/20 14:13:21 roberto Exp $</SPAN>
 ** Standard library for string operations and pattern-matching
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -13,6 +13,7 @@</SPAN>
 #include &lt;ctype.h&gt;
 #include &lt;float.h&gt;
 #include &lt;limits.h&gt;
<SPAN CLASS="add">+#include &lt;locale.h&gt;</SPAN>
 #include &lt;stddef.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;

<SPAN CLASS="etc">@@ -26,7 +27,8 @@</SPAN>
 
 /*
 ** maximum number of captures that a pattern can do during
<SPAN CLASS="del">-** pattern-matching. This limit is arbitrary.</SPAN>
<SPAN CLASS="add">+** pattern-matching. This limit is arbitrary, but must fit in</SPAN>
<SPAN CLASS="add">+** an unsigned char.</SPAN>
 */
 #if !defined(LUA_MAXCAPTURES)
 #define LUA_MAXCAPTURES		32

<SPAN CLASS="etc">@@ -214,9 +216,8 @@</SPAN>
   const char *src_end;  /* end ('\0') of source string */
   const char *p_end;  /* end ('\0') of pattern */
   lua_State *L;
<SPAN CLASS="del">-  size_t nrep;  /* limit to avoid non-linear complexity */</SPAN>
   int matchdepth;  /* control for recursive depth (to avoid C stack overflow) */
<SPAN CLASS="del">-  int level;  /* total number of captures (finished or unfinished) */</SPAN>
<SPAN CLASS="add">+  unsigned char level;  /* total number of captures (finished or unfinished) */</SPAN>
   struct {
     const char *init;
     ptrdiff_t len;

<SPAN CLASS="etc">@@ -234,17 +235,6 @@</SPAN>
 #endif
 
 
<SPAN CLASS="del">-/*</SPAN>
<SPAN CLASS="del">-** parameters to control the maximum number of operators handled in</SPAN>
<SPAN CLASS="del">-** a match (to avoid non-linear complexity). The maximum will be:</SPAN>
<SPAN CLASS="del">-** (subject length) * A_REPS + B_REPS</SPAN>
<SPAN CLASS="del">-*/</SPAN>
<SPAN CLASS="del">-#if !defined(A_REPS)</SPAN>
<SPAN CLASS="del">-#define A_REPS		4</SPAN>
<SPAN CLASS="del">-#define B_REPS		100000</SPAN>
<SPAN CLASS="del">-#endif</SPAN>
<SPAN CLASS="del">-</SPAN>
<SPAN CLASS="del">-</SPAN>
 #define L_ESC		'%'
 #define SPECIALS	"^$*+?.([%-"
 

<SPAN CLASS="etc">@@ -502,8 +492,6 @@</SPAN>
             s = NULL;  /* fail */
         }
         else {  /* matched once */
<SPAN CLASS="del">-          if (ms-&gt;nrep-- == 0)</SPAN>
<SPAN CLASS="del">-            luaL_error(ms-&gt;L, "pattern too complex");</SPAN>
           switch (*ep) {  /* handle optional suffix */
             case '?': {  /* optional */
               const char *res;

<SPAN CLASS="etc">@@ -607,10 +595,6 @@</SPAN>
   ms-&gt;src_init = s;
   ms-&gt;src_end = s + ls;
   ms-&gt;p_end = p + lp;
<SPAN CLASS="del">-  if (ls &lt; (MAX_SIZET - B_REPS) / A_REPS)</SPAN>
<SPAN CLASS="del">-    ms-&gt;nrep = A_REPS * ls + B_REPS;</SPAN>
<SPAN CLASS="del">-  else  /* overflow (very long subject) */</SPAN>
<SPAN CLASS="del">-    ms-&gt;nrep = MAX_SIZET;  /* no limit */</SPAN>
 }
 
 

<SPAN CLASS="etc">@@ -681,6 +665,7 @@</SPAN>
 typedef struct GMatchState {
   const char *src;  /* current position */
   const char *p;  /* pattern */
<SPAN CLASS="add">+  const char *lastmatch;  /* end of last match */</SPAN>
   MatchState ms;  /* match state */
 } GMatchState;
 

<SPAN CLASS="etc">@@ -688,14 +673,12 @@</SPAN>
 static int gmatch_aux (lua_State *L) {
   GMatchState *gm = (GMatchState *)lua_touserdata(L, lua_upvalueindex(3));
   const char *src;
<SPAN CLASS="add">+  gm-&gt;ms.L = L;</SPAN>
   for (src = gm-&gt;src; src &lt;= gm-&gt;ms.src_end; src++) {
     const char *e;
     reprepstate(&amp;gm-&gt;ms);
<SPAN CLASS="del">-    if ((e = match(&amp;gm-&gt;ms, src, gm-&gt;p)) != NULL) {</SPAN>
<SPAN CLASS="del">-      if (e == src)  /* empty match? */</SPAN>
<SPAN CLASS="del">-        gm-&gt;src =src + 1;  /* go at least one position */</SPAN>
<SPAN CLASS="del">-      else</SPAN>
<SPAN CLASS="del">-        gm-&gt;src = e;</SPAN>
<SPAN CLASS="add">+    if ((e = match(&amp;gm-&gt;ms, src, gm-&gt;p)) != NULL &amp;&amp; e != gm-&gt;lastmatch) {</SPAN>
<SPAN CLASS="add">+      gm-&gt;src = gm-&gt;lastmatch = e;</SPAN>
       return push_captures(&amp;gm-&gt;ms, src, e);
     }
   }

<SPAN CLASS="etc">@@ -711,7 +694,7 @@</SPAN>
   lua_settop(L, 2);  /* keep them on closure to avoid being collected */
   gm = (GMatchState *)lua_newuserdata(L, sizeof(GMatchState));
   prepstate(&amp;gm-&gt;ms, L, s, ls, p, lp);
<SPAN CLASS="del">-  gm-&gt;src = s; gm-&gt;p = p;</SPAN>
<SPAN CLASS="add">+  gm-&gt;src = s; gm-&gt;p = p; gm-&gt;lastmatch = NULL;</SPAN>
   lua_pushcclosure(L, gmatch_aux, 3);
   return 1;
 }

<SPAN CLASS="etc">@@ -778,12 +761,13 @@</SPAN>
 
 static int str_gsub (lua_State *L) {
   size_t srcl, lp;
<SPAN CLASS="del">-  const char *src = luaL_checklstring(L, 1, &amp;srcl);</SPAN>
<SPAN CLASS="del">-  const char *p = luaL_checklstring(L, 2, &amp;lp);</SPAN>
<SPAN CLASS="del">-  int tr = lua_type(L, 3);</SPAN>
<SPAN CLASS="del">-  lua_Integer max_s = luaL_optinteger(L, 4, srcl + 1);</SPAN>
<SPAN CLASS="add">+  const char *src = luaL_checklstring(L, 1, &amp;srcl);  /* subject */</SPAN>
<SPAN CLASS="add">+  const char *p = luaL_checklstring(L, 2, &amp;lp);  /* pattern */</SPAN>
<SPAN CLASS="add">+  const char *lastmatch = NULL;  /* end of last match */</SPAN>
<SPAN CLASS="add">+  int tr = lua_type(L, 3);  /* replacement type */</SPAN>
<SPAN CLASS="add">+  lua_Integer max_s = luaL_optinteger(L, 4, srcl + 1);  /* max replacements */</SPAN>
   int anchor = (*p == '^');
<SPAN CLASS="del">-  lua_Integer n = 0;</SPAN>
<SPAN CLASS="add">+  lua_Integer n = 0;  /* replacement count */</SPAN>
   MatchState ms;
   luaL_Buffer b;
   luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||

<SPAN CLASS="etc">@@ -796,16 +780,15 @@</SPAN>
   prepstate(&amp;ms, L, src, srcl, p, lp);
   while (n &lt; max_s) {
     const char *e;
<SPAN CLASS="del">-    reprepstate(&amp;ms);</SPAN>
<SPAN CLASS="del">-    if ((e = match(&amp;ms, src, p)) != NULL) {</SPAN>
<SPAN CLASS="add">+    reprepstate(&amp;ms);  /* (re)prepare state for new match */</SPAN>
<SPAN CLASS="add">+    if ((e = match(&amp;ms, src, p)) != NULL &amp;&amp; e != lastmatch) {  /* match? */</SPAN>
       n++;
<SPAN CLASS="del">-      add_value(&amp;ms, &amp;b, src, e, tr);</SPAN>
<SPAN CLASS="add">+      add_value(&amp;ms, &amp;b, src, e, tr);  /* add replacement to buffer */</SPAN>
<SPAN CLASS="add">+      src = lastmatch = e;</SPAN>
     }
<SPAN CLASS="del">-    if (e &amp;&amp; e&gt;src) /* non empty match? */</SPAN>
<SPAN CLASS="del">-      src = e;  /* skip it */</SPAN>
<SPAN CLASS="del">-    else if (src &lt; ms.src_end)</SPAN>
<SPAN CLASS="add">+    else if (src &lt; ms.src_end)  /* otherwise, skip one character */</SPAN>
       luaL_addchar(&amp;b, *src++);
<SPAN CLASS="del">-    else break;</SPAN>
<SPAN CLASS="add">+    else break;  /* end of subject */</SPAN>
     if (anchor) break;
   }
   luaL_addlstring(&amp;b, src, ms.src_end-src);

<SPAN CLASS="etc">@@ -830,7 +813,6 @@</SPAN>
 ** Hexadecimal floating-point formatter
 */
 
<SPAN CLASS="del">-#include &lt;locale.h&gt;</SPAN>
 #include &lt;math.h&gt;
 
 #define SIZELENMOD	(sizeof(LUA_NUMBER_FRMLEN)/sizeof(char))

<SPAN CLASS="etc">@@ -922,16 +904,14 @@</SPAN>
 #define MAX_FORMAT	32
 
 
<SPAN CLASS="del">-static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {</SPAN>
<SPAN CLASS="del">-  size_t l;</SPAN>
<SPAN CLASS="del">-  const char *s = luaL_checklstring(L, arg, &amp;l);</SPAN>
<SPAN CLASS="add">+static void addquoted (luaL_Buffer *b, const char *s, size_t len) {</SPAN>
   luaL_addchar(b, '"');
<SPAN CLASS="del">-  while (l--) {</SPAN>
<SPAN CLASS="add">+  while (len--) {</SPAN>
     if (*s == '"' || *s == '\\' || *s == '\n') {
       luaL_addchar(b, '\\');
       luaL_addchar(b, *s);
     }
<SPAN CLASS="del">-    else if (*s == '\0' || iscntrl(uchar(*s))) {</SPAN>
<SPAN CLASS="add">+    else if (iscntrl(uchar(*s))) {</SPAN>
       char buff[10];
       if (!isdigit(uchar(*(s+1))))
         l_sprintf(buff, sizeof(buff), "\\%d", (int)uchar(*s));

<SPAN CLASS="etc">@@ -946,6 +926,57 @@</SPAN>
   luaL_addchar(b, '"');
 }
 
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Ensures the 'buff' string uses a dot as the radix character.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
<SPAN CLASS="add">+static void checkdp (char *buff, int nb) {</SPAN>
<SPAN CLASS="add">+  if (memchr(buff, '.', nb) == NULL) {  /* no dot? */</SPAN>
<SPAN CLASS="add">+    char point = lua_getlocaledecpoint();  /* try locale point */</SPAN>
<SPAN CLASS="add">+    char *ppoint = memchr(buff, point, nb);</SPAN>
<SPAN CLASS="add">+    if (ppoint) *ppoint = '.';  /* change it to a dot */</SPAN>
<SPAN CLASS="add">+  }</SPAN>
<SPAN CLASS="add">+}</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+static void addliteral (lua_State *L, luaL_Buffer *b, int arg) {</SPAN>
<SPAN CLASS="add">+  switch (lua_type(L, arg)) {</SPAN>
<SPAN CLASS="add">+    case LUA_TSTRING: {</SPAN>
<SPAN CLASS="add">+      size_t len;</SPAN>
<SPAN CLASS="add">+      const char *s = lua_tolstring(L, arg, &amp;len);</SPAN>
<SPAN CLASS="add">+      addquoted(b, s, len);</SPAN>
<SPAN CLASS="add">+      break;</SPAN>
<SPAN CLASS="add">+    }</SPAN>
<SPAN CLASS="add">+    case LUA_TNUMBER: {</SPAN>
<SPAN CLASS="add">+      char *buff = luaL_prepbuffsize(b, MAX_ITEM);</SPAN>
<SPAN CLASS="add">+      int nb;</SPAN>
<SPAN CLASS="add">+      if (!lua_isinteger(L, arg)) {  /* float? */</SPAN>
<SPAN CLASS="add">+        lua_Number n = lua_tonumber(L, arg);  /* write as hexa ('%a') */</SPAN>
<SPAN CLASS="add">+        nb = lua_number2strx(L, buff, MAX_ITEM, "%" LUA_NUMBER_FRMLEN "a", n);</SPAN>
<SPAN CLASS="add">+        checkdp(buff, nb);  /* ensure it uses a dot */</SPAN>
<SPAN CLASS="add">+      }</SPAN>
<SPAN CLASS="add">+      else {  /* integers */</SPAN>
<SPAN CLASS="add">+        lua_Integer n = lua_tointeger(L, arg);</SPAN>
<SPAN CLASS="add">+        const char *format = (n == LUA_MININTEGER)  /* corner case? */</SPAN>
<SPAN CLASS="add">+                           ? "0x%" LUA_INTEGER_FRMLEN "x"  /* use hexa */</SPAN>
<SPAN CLASS="add">+                           : LUA_INTEGER_FMT;  /* else use default format */</SPAN>
<SPAN CLASS="add">+        nb = l_sprintf(buff, MAX_ITEM, format, n);</SPAN>
<SPAN CLASS="add">+      }</SPAN>
<SPAN CLASS="add">+      luaL_addsize(b, nb);</SPAN>
<SPAN CLASS="add">+      break;</SPAN>
<SPAN CLASS="add">+    }</SPAN>
<SPAN CLASS="add">+    case LUA_TNIL: case LUA_TBOOLEAN: {</SPAN>
<SPAN CLASS="add">+      luaL_tolstring(L, arg, NULL);</SPAN>
<SPAN CLASS="add">+      luaL_addvalue(b);</SPAN>
<SPAN CLASS="add">+      break;</SPAN>
<SPAN CLASS="add">+    }</SPAN>
<SPAN CLASS="add">+    default: {</SPAN>
<SPAN CLASS="add">+      luaL_argerror(L, arg, "value has no literal form");</SPAN>
<SPAN CLASS="add">+    }</SPAN>
<SPAN CLASS="add">+  }</SPAN>
<SPAN CLASS="add">+}</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
 static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
   const char *p = strfrmt;
   while (*p != '\0' &amp;&amp; strchr(FLAGS, *p) != NULL) p++;  /* skip flags */

<SPAN CLASS="etc">@@ -1025,7 +1056,7 @@</SPAN>
           break;
         }
         case 'q': {
<SPAN CLASS="del">-          addquoted(L, &amp;b, arg);</SPAN>
<SPAN CLASS="add">+          addliteral(L, &amp;b, arg);</SPAN>
           break;
         }
         case 's': {

<SPAN CLASS="etc">@@ -1070,8 +1101,8 @@</SPAN>
 
 
 /* value used for padding */
<SPAN CLASS="del">-#if !defined(LUA_PACKPADBYTE)</SPAN>
<SPAN CLASS="del">-#define LUA_PACKPADBYTE		0x00</SPAN>
<SPAN CLASS="add">+#if !defined(LUAL_PACKPADBYTE)</SPAN>
<SPAN CLASS="add">+#define LUAL_PACKPADBYTE		0x00</SPAN>
 #endif
 
 /* maximum size for the binary representation of an integer */

<SPAN CLASS="etc">@@ -1308,7 +1339,7 @@</SPAN>
     KOption opt = getdetails(&amp;h, totalsize, &amp;fmt, &amp;size, &amp;ntoalign);
     totalsize += ntoalign + size;
     while (ntoalign-- &gt; 0)
<SPAN CLASS="del">-     luaL_addchar(&amp;b, LUA_PACKPADBYTE);  /* fill alignment */</SPAN>
<SPAN CLASS="add">+     luaL_addchar(&amp;b, LUAL_PACKPADBYTE);  /* fill alignment */</SPAN>
     arg++;
     switch (opt) {
       case Kint: {  /* signed integers */

<SPAN CLASS="etc">@@ -1343,13 +1374,11 @@</SPAN>
       case Kchar: {  /* fixed-size string */
         size_t len;
         const char *s = luaL_checklstring(L, arg, &amp;len);
<SPAN CLASS="del">-        if ((size_t)size &lt;= len)  /* string larger than (or equal to) needed? */</SPAN>
<SPAN CLASS="del">-          luaL_addlstring(&amp;b, s, size);  /* truncate string to asked size */</SPAN>
<SPAN CLASS="del">-        else {  /* string smaller than needed */</SPAN>
<SPAN CLASS="del">-          luaL_addlstring(&amp;b, s, len);  /* add it all */</SPAN>
<SPAN CLASS="del">-          while (len++ &lt; (size_t)size)  /* pad extra space */</SPAN>
<SPAN CLASS="del">-            luaL_addchar(&amp;b, LUA_PACKPADBYTE);</SPAN>
<SPAN CLASS="del">-        }</SPAN>
<SPAN CLASS="add">+        luaL_argcheck(L, len &lt;= (size_t)size, arg,</SPAN>
<SPAN CLASS="add">+                         "string longer than given size");</SPAN>
<SPAN CLASS="add">+        luaL_addlstring(&amp;b, s, len);  /* add string */</SPAN>
<SPAN CLASS="add">+        while (len++ &lt; (size_t)size)  /* pad extra space */</SPAN>
<SPAN CLASS="add">+          luaL_addchar(&amp;b, LUAL_PACKPADBYTE);</SPAN>
         break;
       }
       case Kstring: {  /* strings with length count */

<SPAN CLASS="etc">@@ -1372,7 +1401,7 @@</SPAN>
         totalsize += len + 1;
         break;
       }
<SPAN CLASS="del">-      case Kpadding: luaL_addchar(&amp;b, LUA_PACKPADBYTE);  /* FALLTHROUGH */</SPAN>
<SPAN CLASS="add">+      case Kpadding: luaL_addchar(&amp;b, LUAL_PACKPADBYTE);  /* FALLTHROUGH */</SPAN>
       case Kpaddalign: case Knop:
         arg--;  /* undo increment */
         break;

<SPAN CLASS="diff">src/ltablib.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: ltablib.c,v 1.90 2015/11/25 12:48:57 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: ltablib.c,v 1.93 2016/02/25 19:41:54 roberto Exp $</SPAN>
 ** Library for Table Manipulation
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -53,7 +53,7 @@</SPAN>
       lua_pop(L, n);  /* pop metatable and tested metamethods */
     }
     else
<SPAN CLASS="del">-      luaL_argerror(L, arg, "table expected");  /* force an error */</SPAN>
<SPAN CLASS="add">+      luaL_checktype(L, arg, LUA_TTABLE);  /* force an error */</SPAN>
   }
 }
 

<SPAN CLASS="etc">@@ -139,7 +139,7 @@</SPAN>
     n = e - f + 1;  /* number of elements to move */
     luaL_argcheck(L, t &lt;= LUA_MAXINTEGER - n + 1, 4,
                   "destination wrap around");
<SPAN CLASS="del">-    if (t &gt; e || t &lt;= f || tt != 1) {</SPAN>
<SPAN CLASS="add">+    if (t &gt; e || t &lt;= f || (tt != 1 &amp;&amp; !lua_compare(L, 1, tt, LUA_OPEQ))) {</SPAN>
       for (i = 0; i &lt; n; i++) {
         lua_geti(L, 1, f + i);
         lua_seti(L, tt, t + i);

<SPAN CLASS="etc">@@ -152,7 +152,7 @@</SPAN>
       }
     }
   }
<SPAN CLASS="del">-  lua_pushvalue(L, tt);  /* return "to table" */</SPAN>
<SPAN CLASS="add">+  lua_pushvalue(L, tt);  /* return destination table */</SPAN>
   return 1;
 }
 

<SPAN CLASS="etc">@@ -172,7 +172,7 @@</SPAN>
   size_t lsep;
   const char *sep = luaL_optlstring(L, 2, "", &amp;lsep);
   lua_Integer i = luaL_optinteger(L, 3, 1);
<SPAN CLASS="del">-  last = luaL_opt(L, luaL_checkinteger, 4, last);</SPAN>
<SPAN CLASS="add">+  last = luaL_optinteger(L, 4, last);</SPAN>
   luaL_buffinit(L, &amp;b);
   for (; i &lt; last; i++) {
     addfield(L, &amp;b, i);

<SPAN CLASS="etc">@@ -232,6 +232,10 @@</SPAN>
 */
 
 
<SPAN CLASS="add">+/* type for array indices */</SPAN>
<SPAN CLASS="add">+typedef unsigned int IdxT;</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
 /*
 ** Produce a "random" 'unsigned int' to randomize pivot choice. This
 ** macro is used only when 'sort' detects a big imbalance in the result

<SPAN CLASS="etc">@@ -270,7 +274,7 @@</SPAN>
 #define RANLIMIT	100u
 
 
<SPAN CLASS="del">-static void set2 (lua_State *L, unsigned int i, unsigned int j) {</SPAN>
<SPAN CLASS="add">+static void set2 (lua_State *L, IdxT i, IdxT j) {</SPAN>
   lua_seti(L, 1, i);
   lua_seti(L, 1, j);
 }

<SPAN CLASS="etc">@@ -303,10 +307,9 @@</SPAN>
 ** Pos-condition: a[lo .. i - 1] &lt;= a[i] == P &lt;= a[i + 1 .. up]
 ** returns 'i'.
 */
<SPAN CLASS="del">-static unsigned int partition (lua_State *L, unsigned int lo,</SPAN>
<SPAN CLASS="del">-                                             unsigned int up) {</SPAN>
<SPAN CLASS="del">-  unsigned int i = lo;  /* will be incremented before first use */</SPAN>
<SPAN CLASS="del">-  unsigned int j = up - 1;  /* will be decremented before first use */</SPAN>
<SPAN CLASS="add">+static IdxT partition (lua_State *L, IdxT lo, IdxT up) {</SPAN>
<SPAN CLASS="add">+  IdxT i = lo;  /* will be incremented before first use */</SPAN>
<SPAN CLASS="add">+  IdxT j = up - 1;  /* will be decremented before first use */</SPAN>
   /* loop invariant: a[lo .. i] &lt;= P &lt;= a[j .. up] */
   for (;;) {
     /* next loop: repeat ++i while a[i] &lt; P */

<SPAN CLASS="etc">@@ -340,10 +343,9 @@</SPAN>
 ** Choose an element in the middle (2nd-3th quarters) of [lo,up]
 ** "randomized" by 'rnd'
 */
<SPAN CLASS="del">-static unsigned int choosePivot (unsigned int lo, unsigned int up,</SPAN>
<SPAN CLASS="del">-                                 unsigned int rnd) {</SPAN>
<SPAN CLASS="del">-  unsigned int r4 = (unsigned int)(up - lo) / 4u;  /* range/4 */</SPAN>
<SPAN CLASS="del">-  unsigned int p = rnd % (r4 * 2) + (lo + r4);</SPAN>
<SPAN CLASS="add">+static IdxT choosePivot (IdxT lo, IdxT up, unsigned int rnd) {</SPAN>
<SPAN CLASS="add">+  IdxT r4 = (up - lo) / 4;  /* range/4 */</SPAN>
<SPAN CLASS="add">+  IdxT p = rnd % (r4 * 2) + (lo + r4);</SPAN>
   lua_assert(lo + r4 &lt;= p &amp;&amp; p &lt;= up - r4);
   return p;
 }

<SPAN CLASS="etc">@@ -352,11 +354,11 @@</SPAN>
 /*
 ** QuickSort algorithm (recursive function)
 */
<SPAN CLASS="del">-static void auxsort (lua_State *L, unsigned int lo, unsigned int up,</SPAN>
<SPAN CLASS="add">+static void auxsort (lua_State *L, IdxT lo, IdxT up,</SPAN>
                                    unsigned int rnd) {
   while (lo &lt; up) {  /* loop for tail recursion */
<SPAN CLASS="del">-    unsigned int p;  /* Pivot index */</SPAN>
<SPAN CLASS="del">-    unsigned int n;  /* to be used later */</SPAN>
<SPAN CLASS="add">+    IdxT p;  /* Pivot index */</SPAN>
<SPAN CLASS="add">+    IdxT n;  /* to be used later */</SPAN>
     /* sort elements 'lo', 'p', and 'up' */
     lua_geti(L, 1, lo);
     lua_geti(L, 1, up);

<SPAN CLASS="etc">@@ -400,7 +402,7 @@</SPAN>
       n = up - p;  /* size of smaller interval */
       up = p - 1;  /* tail call for [lo .. p - 1]  (lower interval) */
     }
<SPAN CLASS="del">-    if ((up - lo) / 128u &gt; n) /* partition too imbalanced? */</SPAN>
<SPAN CLASS="add">+    if ((up - lo) / 128 &gt; n) /* partition too imbalanced? */</SPAN>
       rnd = l_randomizePivot();  /* try a new randomization */
   }  /* tail call auxsort(L, lo, up, rnd) */
 }

<SPAN CLASS="etc">@@ -410,11 +412,10 @@</SPAN>
   lua_Integer n = aux_getn(L, 1, TAB_RW);
   if (n &gt; 1) {  /* non-trivial interval? */
     luaL_argcheck(L, n &lt; INT_MAX, 1, "array too big");
<SPAN CLASS="del">-    luaL_checkstack(L, 40, "");  /* assume array is smaller than 2^40 */</SPAN>
     if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */
       luaL_checktype(L, 2, LUA_TFUNCTION);  /* must be a function */
     lua_settop(L, 2);  /* make sure there are two arguments */
<SPAN CLASS="del">-    auxsort(L, 1, (unsigned int)n, 0u);</SPAN>
<SPAN CLASS="add">+    auxsort(L, 1, (IdxT)n, 0);</SPAN>
   }
   return 0;
 }

<SPAN CLASS="diff">src/ltm.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: ltm.c,v 2.36 2015/11/03 15:47:30 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: ltm.c,v 2.37 2016/02/26 19:20:15 roberto Exp $</SPAN>
 ** Tag methods
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -83,6 +83,22 @@</SPAN>
 }
 
 
<SPAN CLASS="add">+/*</SPAN>
<SPAN CLASS="add">+** Return the name of the type of an object. For tables and userdata</SPAN>
<SPAN CLASS="add">+** with metatable, use their '__name' metafield, if present.</SPAN>
<SPAN CLASS="add">+*/</SPAN>
<SPAN CLASS="add">+const char *luaT_objtypename (lua_State *L, const TValue *o) {</SPAN>
<SPAN CLASS="add">+  Table *mt;</SPAN>
<SPAN CLASS="add">+  if ((ttistable(o) &amp;&amp; (mt = hvalue(o)-&gt;metatable) != NULL) ||</SPAN>
<SPAN CLASS="add">+      (ttisfulluserdata(o) &amp;&amp; (mt = uvalue(o)-&gt;metatable) != NULL)) {</SPAN>
<SPAN CLASS="add">+    const TValue *name = luaH_getshortstr(mt, luaS_new(L, "__name"));</SPAN>
<SPAN CLASS="add">+    if (ttisstring(name))  /* is '__name' a string? */</SPAN>
<SPAN CLASS="add">+      return getstr(tsvalue(name));  /* use it as type name */</SPAN>
<SPAN CLASS="add">+  }</SPAN>
<SPAN CLASS="add">+  return ttypename(ttnov(o));  /* else use standard type name */</SPAN>
<SPAN CLASS="add">+}</SPAN>
<SPAN CLASS="add">+</SPAN>
<SPAN CLASS="add">+</SPAN>
 void luaT_callTM (lua_State *L, const TValue *f, const TValue *p1,
                   const TValue *p2, TValue *p3, int hasres) {
   ptrdiff_t result = savestack(L, p3);

<SPAN CLASS="diff">src/ltm.h</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: ltm.h,v 2.21 2014/10/25 11:50:46 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: ltm.h,v 2.22 2016/02/26 19:20:15 roberto Exp $</SPAN>
 ** Tag methods
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -51,11 +51,12 @@</SPAN>
 #define fasttm(l,et,e)	gfasttm(G(l), et, e)
 
 #define ttypename(x)	luaT_typenames_[(x) + 1]
<SPAN CLASS="del">-#define objtypename(x)	ttypename(ttnov(x))</SPAN>
 
 LUAI_DDEC const char *const luaT_typenames_[LUA_TOTALTAGS];
 
 
<SPAN CLASS="add">+LUAI_FUNC const char *luaT_objtypename (lua_State *L, const TValue *o);</SPAN>
<SPAN CLASS="add">+</SPAN>
 LUAI_FUNC const TValue *luaT_gettm (Table *events, TMS event, TString *ename);
 LUAI_FUNC const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o,
                                                        TMS event);

<SPAN CLASS="diff">src/lua.h</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lua.h,v 1.329 2015/11/13 17:18:42 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lua.h,v 1.331 2016/05/30 15:53:28 roberto Exp $</SPAN>
 ** Lua - A Scripting Language
 ** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
 ** See Copyright Notice at the end of this file

<SPAN CLASS="etc">@@ -19,11 +19,11 @@</SPAN>
 #define LUA_VERSION_MAJOR	"5"
 #define LUA_VERSION_MINOR	"3"
 #define LUA_VERSION_NUM		503
<SPAN CLASS="del">-#define LUA_VERSION_RELEASE	"2"</SPAN>
<SPAN CLASS="add">+#define LUA_VERSION_RELEASE	"3"</SPAN>
 
 #define LUA_VERSION	"Lua " LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
 #define LUA_RELEASE	LUA_VERSION "." LUA_VERSION_RELEASE
<SPAN CLASS="del">-#define LUA_COPYRIGHT	LUA_RELEASE "  Copyright (C) 1994-2015 Lua.org, PUC-Rio"</SPAN>
<SPAN CLASS="add">+#define LUA_COPYRIGHT	LUA_RELEASE "  Copyright (C) 1994-2016 Lua.org, PUC-Rio"</SPAN>
 #define LUA_AUTHORS	"R. Ierusalimschy, L. H. de Figueiredo, W. Celes"
 
 

<SPAN CLASS="etc">@@ -361,7 +361,7 @@</SPAN>
 #define lua_pushliteral(L, s)	lua_pushstring(L, "" s)
 
 #define lua_pushglobaltable(L)  \
<SPAN CLASS="del">-	lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS)</SPAN>
<SPAN CLASS="add">+	((void)lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS))</SPAN>
 
 #define lua_tostring(L,i)	lua_tolstring(L, (i), NULL)
 

<SPAN CLASS="etc">@@ -460,7 +460,7 @@</SPAN>
 
 
 /******************************************************************************
<SPAN CLASS="del">-* Copyright (C) 1994-2015 Lua.org, PUC-Rio.</SPAN>
<SPAN CLASS="add">+* Copyright (C) 1994-2016 Lua.org, PUC-Rio.</SPAN>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the

<SPAN CLASS="diff">src/luaconf.h</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: luaconf.h,v 1.254 2015/10/21 18:17:40 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: luaconf.h,v 1.255 2016/05/01 20:06:09 roberto Exp $</SPAN>
 ** Configuration file for Lua
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -612,7 +612,7 @@</SPAN>
 ** provide its own implementation.
 */
 #if !defined(LUA_USE_C89)
<SPAN CLASS="del">-#define lua_number2strx(L,b,sz,f,n)	l_sprintf(b,sz,f,n)</SPAN>
<SPAN CLASS="add">+#define lua_number2strx(L,b,sz,f,n)	((void)L, l_sprintf(b,sz,f,n))</SPAN>
 #endif
 
 

<SPAN CLASS="diff">src/lvm.c</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lvm.c,v 2.265 2015/11/23 11:30:45 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lvm.c,v 2.268 2016/02/05 19:59:14 roberto Exp $</SPAN>
 ** Lua virtual machine
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -153,55 +153,69 @@</SPAN>
 
 
 /*
<SPAN CLASS="del">-** Complete a table access: if 't' is a table, 'tm' has its metamethod;</SPAN>
<SPAN CLASS="del">-** otherwise, 'tm' is NULL.</SPAN>
<SPAN CLASS="add">+** Finish the table access 'val = t[key]'.</SPAN>
<SPAN CLASS="add">+** if 'slot' is NULL, 't' is not a table; otherwise, 'slot' points to</SPAN>
<SPAN CLASS="add">+** t[k] entry (which must be nil).</SPAN>
 */
 void luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,
<SPAN CLASS="del">-                      const TValue *tm) {</SPAN>
<SPAN CLASS="add">+                      const TValue *slot) {</SPAN>
   int loop;  /* counter to avoid infinite loops */
<SPAN CLASS="del">-  lua_assert(tm != NULL || !ttistable(t));</SPAN>
<SPAN CLASS="add">+  const TValue *tm;  /* metamethod */</SPAN>
   for (loop = 0; loop &lt; MAXTAGLOOP; loop++) {
<SPAN CLASS="del">-    if (tm == NULL) {  /* no metamethod (from a table)? */</SPAN>
<SPAN CLASS="del">-      if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))</SPAN>
<SPAN CLASS="add">+    if (slot == NULL) {  /* 't' is not a table? */</SPAN>
<SPAN CLASS="add">+      lua_assert(!ttistable(t));</SPAN>
<SPAN CLASS="add">+      tm = luaT_gettmbyobj(L, t, TM_INDEX);</SPAN>
<SPAN CLASS="add">+      if (ttisnil(tm))</SPAN>
         luaG_typeerror(L, t, "index");  /* no metamethod */
<SPAN CLASS="add">+      /* else will try the metamethod */</SPAN>
     }
<SPAN CLASS="del">-    if (ttisfunction(tm)) {  /* metamethod is a function */</SPAN>
<SPAN CLASS="add">+    else {  /* 't' is a table */</SPAN>
<SPAN CLASS="add">+      lua_assert(ttisnil(slot));</SPAN>
<SPAN CLASS="add">+      tm = fasttm(L, hvalue(t)-&gt;metatable, TM_INDEX);  /* table's metamethod */</SPAN>
<SPAN CLASS="add">+      if (tm == NULL) {  /* no metamethod? */</SPAN>
<SPAN CLASS="add">+        setnilvalue(val);  /* result is nil */</SPAN>
<SPAN CLASS="add">+        return;</SPAN>
<SPAN CLASS="add">+      }</SPAN>
<SPAN CLASS="add">+      /* else will try the metamethod */</SPAN>
<SPAN CLASS="add">+    }</SPAN>
<SPAN CLASS="add">+    if (ttisfunction(tm)) {  /* is metamethod a function? */</SPAN>
       luaT_callTM(L, tm, t, key, val, 1);  /* call it */
       return;
     }
<SPAN CLASS="del">-    t = tm;  /* else repeat access over 'tm' */</SPAN>
<SPAN CLASS="del">-    if (luaV_fastget(L,t,key,tm,luaH_get)) {  /* try fast track */</SPAN>
<SPAN CLASS="del">-      setobj2s(L, val, tm);  /* done */</SPAN>
<SPAN CLASS="add">+    t = tm;  /* else try to access 'tm[key]' */</SPAN>
<SPAN CLASS="add">+    if (luaV_fastget(L,t,key,slot,luaH_get)) {  /* fast track? */</SPAN>
<SPAN CLASS="add">+      setobj2s(L, val, slot);  /* done */</SPAN>
       return;
     }
<SPAN CLASS="del">-    /* else repeat */</SPAN>
<SPAN CLASS="add">+    /* else repeat (tail call 'luaV_finishget') */</SPAN>
   }
<SPAN CLASS="del">-  luaG_runerror(L, "gettable chain too long; possible loop");</SPAN>
<SPAN CLASS="add">+  luaG_runerror(L, "'__index' chain too long; possible loop");</SPAN>
 }
 
 
 /*
<SPAN CLASS="del">-** Main function for table assignment (invoking metamethods if needed).</SPAN>
<SPAN CLASS="del">-** Compute 't[key] = val'</SPAN>
<SPAN CLASS="add">+** Finish a table assignment 't[key] = val'.</SPAN>
<SPAN CLASS="add">+** If 'slot' is NULL, 't' is not a table.  Otherwise, 'slot' points</SPAN>
<SPAN CLASS="add">+** to the entry 't[key]', or to 'luaO_nilobject' if there is no such</SPAN>
<SPAN CLASS="add">+** entry.  (The value at 'slot' must be nil, otherwise 'luaV_fastset'</SPAN>
<SPAN CLASS="add">+** would have done the job.)</SPAN>
 */
 void luaV_finishset (lua_State *L, const TValue *t, TValue *key,
<SPAN CLASS="del">-                     StkId val, const TValue *oldval) {</SPAN>
<SPAN CLASS="add">+                     StkId val, const TValue *slot) {</SPAN>
   int loop;  /* counter to avoid infinite loops */
   for (loop = 0; loop &lt; MAXTAGLOOP; loop++) {
<SPAN CLASS="del">-    const TValue *tm;</SPAN>
<SPAN CLASS="del">-    if (oldval != NULL) {</SPAN>
<SPAN CLASS="del">-      lua_assert(ttistable(t) &amp;&amp; ttisnil(oldval));</SPAN>
<SPAN CLASS="del">-      /* must check the metamethod */</SPAN>
<SPAN CLASS="del">-      if ((tm = fasttm(L, hvalue(t)-&gt;metatable, TM_NEWINDEX)) == NULL &amp;&amp;</SPAN>
<SPAN CLASS="del">-         /* no metamethod; is there a previous entry in the table? */</SPAN>
<SPAN CLASS="del">-         (oldval != luaO_nilobject ||</SPAN>
<SPAN CLASS="del">-         /* no previous entry; must create one. (The next test is</SPAN>
<SPAN CLASS="del">-            always true; we only need the assignment.) */</SPAN>
<SPAN CLASS="del">-         (oldval = luaH_newkey(L, hvalue(t), key), 1))) {</SPAN>
<SPAN CLASS="add">+    const TValue *tm;  /* '__newindex' metamethod */</SPAN>
<SPAN CLASS="add">+    if (slot != NULL) {  /* is 't' a table? */</SPAN>
<SPAN CLASS="add">+      Table *h = hvalue(t);  /* save 't' table */</SPAN>
<SPAN CLASS="add">+      lua_assert(ttisnil(slot));  /* old value must be nil */</SPAN>
<SPAN CLASS="add">+      tm = fasttm(L, h-&gt;metatable, TM_NEWINDEX);  /* get metamethod */</SPAN>
<SPAN CLASS="add">+      if (tm == NULL) {  /* no metamethod? */</SPAN>
<SPAN CLASS="add">+        if (slot == luaO_nilobject)  /* no previous entry? */</SPAN>
<SPAN CLASS="add">+          slot = luaH_newkey(L, h, key);  /* create one */</SPAN>
         /* no metamethod and (now) there is an entry with given key */
<SPAN CLASS="del">-        setobj2t(L, cast(TValue *, oldval), val);</SPAN>
<SPAN CLASS="del">-        invalidateTMcache(hvalue(t));</SPAN>
<SPAN CLASS="del">-        luaC_barrierback(L, hvalue(t), val);</SPAN>
<SPAN CLASS="add">+        setobj2t(L, cast(TValue *, slot), val);  /* set its new value */</SPAN>
<SPAN CLASS="add">+        invalidateTMcache(h);</SPAN>
<SPAN CLASS="add">+        luaC_barrierback(L, h, val);</SPAN>
         return;
       }
       /* else will try the metamethod */

<SPAN CLASS="etc">@@ -216,11 +230,11 @@</SPAN>
       return;
     }
     t = tm;  /* else repeat assignment over 'tm' */
<SPAN CLASS="del">-    if (luaV_fastset(L, t, key, oldval, luaH_get, val))</SPAN>
<SPAN CLASS="add">+    if (luaV_fastset(L, t, key, slot, luaH_get, val))</SPAN>
       return;  /* done */
     /* else loop */
   }
<SPAN CLASS="del">-  luaG_runerror(L, "settable chain too long; possible loop");</SPAN>
<SPAN CLASS="add">+  luaG_runerror(L, "'__newindex' chain too long; possible loop");</SPAN>
 }
 
 

<SPAN CLASS="etc">@@ -738,18 +752,28 @@</SPAN>
            luai_threadyield(L); }
 
 
<SPAN CLASS="add">+/* fetch an instruction and prepare its execution */</SPAN>
<SPAN CLASS="add">+#define vmfetch()	{ \</SPAN>
<SPAN CLASS="add">+  i = *(ci-&gt;u.l.savedpc++); \</SPAN>
<SPAN CLASS="add">+  if (L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) \</SPAN>
<SPAN CLASS="add">+    Protect(luaG_traceexec(L)); \</SPAN>
<SPAN CLASS="add">+  ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */ \</SPAN>
<SPAN CLASS="add">+  lua_assert(base == ci-&gt;u.l.base); \</SPAN>
<SPAN CLASS="add">+  lua_assert(base &lt;= L-&gt;top &amp;&amp; L-&gt;top &lt; L-&gt;stack + L-&gt;stacksize); \</SPAN>
<SPAN CLASS="add">+}</SPAN>
<SPAN CLASS="add">+</SPAN>
 #define vmdispatch(o)	switch(o)
 #define vmcase(l)	case l:
 #define vmbreak		break
 
 
 /*
<SPAN CLASS="del">-** copy of 'luaV_gettable', but protecting call to potential metamethod</SPAN>
<SPAN CLASS="del">-** (which can reallocate the stack)</SPAN>
<SPAN CLASS="add">+** copy of 'luaV_gettable', but protecting the call to potential</SPAN>
<SPAN CLASS="add">+** metamethod (which can reallocate the stack)</SPAN>
 */
<SPAN CLASS="del">-#define gettableProtected(L,t,k,v)  { const TValue *aux; \</SPAN>
<SPAN CLASS="del">-  if (luaV_fastget(L,t,k,aux,luaH_get)) { setobj2s(L, v, aux); } \</SPAN>
<SPAN CLASS="del">-  else Protect(luaV_finishget(L,t,k,v,aux)); }</SPAN>
<SPAN CLASS="add">+#define gettableProtected(L,t,k,v)  { const TValue *slot; \</SPAN>
<SPAN CLASS="add">+  if (luaV_fastget(L,t,k,slot,luaH_get)) { setobj2s(L, v, slot); } \</SPAN>
<SPAN CLASS="add">+  else Protect(luaV_finishget(L,t,k,v,slot)); }</SPAN>
 
 
 /* same for 'luaV_settable' */

<SPAN CLASS="etc">@@ -772,14 +796,9 @@</SPAN>
   base = ci-&gt;u.l.base;  /* local copy of function's base */
   /* main loop of interpreter */
   for (;;) {
<SPAN CLASS="del">-    Instruction i = *(ci-&gt;u.l.savedpc++);</SPAN>
<SPAN CLASS="add">+    Instruction i;</SPAN>
     StkId ra;
<SPAN CLASS="del">-    if (L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT))</SPAN>
<SPAN CLASS="del">-      Protect(luaG_traceexec(L));</SPAN>
<SPAN CLASS="del">-    /* WARNING: several calls may realloc the stack and invalidate 'ra' */</SPAN>
<SPAN CLASS="del">-    ra = RA(i);</SPAN>
<SPAN CLASS="del">-    lua_assert(base == ci-&gt;u.l.base);</SPAN>
<SPAN CLASS="del">-    lua_assert(base &lt;= L-&gt;top &amp;&amp; L-&gt;top &lt; L-&gt;stack + L-&gt;stacksize);</SPAN>
<SPAN CLASS="add">+    vmfetch();</SPAN>
     vmdispatch (GET_OPCODE(i)) {
       vmcase(OP_MOVE) {
         setobjs2s(L, ra, RB(i));

<SPAN CLASS="diff">src/lvm.h</SPAN>

<SPAN CLASS="etc">@@ -1,5 +1,5 @@</SPAN>
 /*
<SPAN CLASS="del">-** $Id: lvm.h,v 2.39 2015/09/09 13:44:07 roberto Exp $</SPAN>
<SPAN CLASS="add">+** $Id: lvm.h,v 2.40 2016/01/05 16:07:21 roberto Exp $</SPAN>
 ** Lua virtual machine
 ** See Copyright Notice in lua.h
 */

<SPAN CLASS="etc">@@ -49,25 +49,24 @@</SPAN>
 
 
 /*
<SPAN CLASS="del">-** fast track for 'gettable': 1 means 'aux' points to resulted value;</SPAN>
<SPAN CLASS="del">-** 0 means 'aux' is metamethod (if 't' is a table) or NULL. 'f' is</SPAN>
<SPAN CLASS="del">-** the raw get function to use.</SPAN>
<SPAN CLASS="add">+** fast track for 'gettable': if 't' is a table and 't[k]' is not nil,</SPAN>
<SPAN CLASS="add">+** return 1 with 'slot' pointing to 't[k]' (final result).  Otherwise,</SPAN>
<SPAN CLASS="add">+** return 0 (meaning it will have to check metamethod) with 'slot'</SPAN>
<SPAN CLASS="add">+** pointing to a nil 't[k]' (if 't' is a table) or NULL (otherwise).</SPAN>
<SPAN CLASS="add">+** 'f' is the raw get function to use.</SPAN>
 */
<SPAN CLASS="del">-#define luaV_fastget(L,t,k,aux,f) \</SPAN>
<SPAN CLASS="add">+#define luaV_fastget(L,t,k,slot,f) \</SPAN>
   (!ttistable(t)  \
<SPAN CLASS="del">-   ? (aux = NULL, 0)  /* not a table; 'aux' is NULL and result is 0 */  \</SPAN>
<SPAN CLASS="del">-   : (aux = f(hvalue(t), k),  /* else, do raw access */  \</SPAN>
<SPAN CLASS="del">-      !ttisnil(aux) ? 1  /* result not nil? 'aux' has it */  \</SPAN>
<SPAN CLASS="del">-      : (aux = fasttm(L, hvalue(t)-&gt;metatable, TM_INDEX),  /* get metamethod */\</SPAN>
<SPAN CLASS="del">-         aux != NULL  ? 0  /* has metamethod? must call it */  \</SPAN>
<SPAN CLASS="del">-         : (aux = luaO_nilobject, 1))))  /* else, final result is nil */</SPAN>
<SPAN CLASS="add">+   ? (slot = NULL, 0)  /* not a table; 'slot' is NULL and result is 0 */  \</SPAN>
<SPAN CLASS="add">+   : (slot = f(hvalue(t), k),  /* else, do raw access */  \</SPAN>
<SPAN CLASS="add">+      !ttisnil(slot)))  /* result not nil? */</SPAN>
 
 /*
 ** standard implementation for 'gettable'
 */
<SPAN CLASS="del">-#define luaV_gettable(L,t,k,v) { const TValue *aux; \</SPAN>
<SPAN CLASS="del">-  if (luaV_fastget(L,t,k,aux,luaH_get)) { setobj2s(L, v, aux); } \</SPAN>
<SPAN CLASS="del">-  else luaV_finishget(L,t,k,v,aux); }</SPAN>
<SPAN CLASS="add">+#define luaV_gettable(L,t,k,v) { const TValue *slot; \</SPAN>
<SPAN CLASS="add">+  if (luaV_fastget(L,t,k,slot,luaH_get)) { setobj2s(L, v, slot); } \</SPAN>
<SPAN CLASS="add">+  else luaV_finishget(L,t,k,v,slot); }</SPAN>
 
 
 /*

<SPAN CLASS="etc">@@ -100,9 +99,9 @@</SPAN>
 LUAI_FUNC int luaV_tonumber_ (const TValue *obj, lua_Number *n);
 LUAI_FUNC int luaV_tointeger (const TValue *obj, lua_Integer *p, int mode);
 LUAI_FUNC void luaV_finishget (lua_State *L, const TValue *t, TValue *key,
<SPAN CLASS="del">-                               StkId val, const TValue *tm);</SPAN>
<SPAN CLASS="add">+                               StkId val, const TValue *slot);</SPAN>
 LUAI_FUNC void luaV_finishset (lua_State *L, const TValue *t, TValue *key,
<SPAN CLASS="del">-                               StkId val, const TValue *oldval);</SPAN>
<SPAN CLASS="add">+                               StkId val, const TValue *slot);</SPAN>
 LUAI_FUNC void luaV_finishOp (lua_State *L);
 LUAI_FUNC void luaV_execute (lua_State *L);
 LUAI_FUNC void luaV_concat (lua_State *L, int total);
</PRE>

<P CLASS="footer">
Last update:
Mon Jun  6 23:46:08 BRT 2016
</P>

</BODY>
</HTML>
